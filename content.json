{"meta":{"title":"思想直播信号","subtitle":"醉心天地，码代云轻","description":"电子科大小硕","author":"wonderxiao","url":"https://wonderxiao.github.io"},"pages":[{"title":"","date":"2018-05-04T13:23:50.885Z","updated":"2017-10-12T11:55:00.000Z","comments":true,"path":"album/lazyload.min.js","permalink":"https://wonderxiao.github.io/album/lazyload.min.js","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2018-05-03T13:31:25.706Z","updated":"2018-05-03T07:58:30.593Z","comments":false,"path":"/404.html","permalink":"https://wonderxiao.github.io//404.html","excerpt":"","text":""},{"title":"关于","date":"2018-05-04T13:49:20.598Z","updated":"2018-05-04T13:49:20.598Z","comments":false,"path":"about/index.html","permalink":"https://wonderxiao.github.io/about/index.html","excerpt":"","text":"本人工科生一枚，喜欢代码给我带来的乐趣！喜欢在互联网的小窝里，倒腾自己喜欢的东西。平时，喜欢撸铁来健身。希望自己以后都能认真坚持的写博客，好好经营自己的这块天地！就像白鹿原上白嘉轩说的，把自己的这块地好好种好。我要好好地把自己的这一亩三分地打理好。平常心，平淡世界！用镜头看天，用代码写梦，丈剑走天下！"},{"title":"","date":"2018-05-04T13:23:50.874Z","updated":"2017-10-12T14:55:03.000Z","comments":true,"path":"album/data.json","permalink":"https://wonderxiao.github.io/album/data.json","excerpt":"","text":"{\"list\":[{\"date\":\"2017-10\",\"arr\":{\"text\":[\"创建连接\",\"创建仓库\",\"图1\",\"效果图\",\"窗户\",\"漂流\"],\"type\":[\"image\",\"image\",\"image\",\"image\",\"image\",\"image\"],\"month\":10,\"link\":[\"2017-10-12_创建连接.png\",\"2017-10-12_创建仓库.png\",\"2017-10-12_图1.png\",\"2017-10-12_效果图.png\",\"2017-10-11_窗户.png\",\"2017-10-11_漂流.png\"],\"year\":2017}}]}"},{"title":"相册","date":"2018-05-04T13:23:50.877Z","updated":"2018-05-04T12:58:14.426Z","comments":false,"path":"album/index.html","permalink":"https://wonderxiao.github.io/album/index.html","excerpt":"","text":"Photos 待续 图片正在加载中… (function() { var loadScript = function(path) { var $script = document.createElement('script') document.getElementsByTagName('body')[0].appendChild($script) $script.setAttribute('src', path) } setTimeout(function() { loadScript('./ins.js') }, 0) })()"},{"title":"","date":"2018-05-04T13:23:50.879Z","updated":"2017-10-11T12:00:03.000Z","comments":true,"path":"album/ins.css","permalink":"https://wonderxiao.github.io/album/ins.css","excerpt":"","text":"#post-instagram{ padding: 30px; } #post-instagram .article-entry{ padding-right: 0; } .instagram{ position: relative; min-height: 500px; } .instagram img { width: 100%; } .instagram .year { font-size: 16px; } .instagram .open-ins{ padding: 10px 0; color: #cdcdcd; } .instagram .open-ins:hover{ color: #657b83; } .instagram .year{ display: inline; } .instagram .thumb { width: 25%; height: 0; padding-bottom: 25%; position: relative; display: inline-block; text-align: center; background: #ededed; outline: 1px solid #ddd; } .instagram .thumb a { position: relative; } .instagram .album h1 em{ font-style: normal; font-size: 14px; margin-left: 10px; } .instagram .album ul{ display: flex; flex-wrap: wrap; clear: both; width: 100%; text-align: left; } .instagram .album li{ list-style: none; display: inline-block; box-sizing: border-box; padding: 0 5px; margin-bottom: -10px; height: 0; width: 25%; position: relative; padding-bottom: 25%; } .instagram .album li:before{ display: none; } .instagram .album div.img-box{ position: absolute; width: 90%; height: 90%; -webkit-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); -moz-box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); box-shadow: 0 1px 0 rgba(255,255,255,0.4), 0 1px 0 1px rgba(255,255,255,0.1); } .instagram .album div.img-box img{ width: 100%; height: 100%; position: absolute; z-index: 2; } .instagram .album div.img-box .img-bg{ position: absolute; top: 0; left: 0; bottom: 0px; width: 100%; margin: -5px; padding: 5px; -webkit-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -moz-box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); box-shadow: 0 0 0 1px rgba(0,0,0,.04), 0 1px 5px rgba(0,0,0,0.1); -webkit-transition: all 0.15s ease-out 0.1s; -moz-transition: all 0.15s ease-out 0.1s; -o-transition: all 0.15s ease-out 0.1s; transition: all 0.15s ease-out 0.1s; opacity: 0.2; cursor: pointer; display: block; z-index: 3; } .instagram .album div.img-box .icon { font-size: 14px; position: absolute; left: 50%; top: 50%; margin-left: -7px; margin-top: -7px; color: #999; z-index: 1; } .instagram .album div.img-box .img-bg:hover{ opacity: 0; } .photos-btn-wrap { border-bottom: 1px solid #e5e5e5; margin-bottom: 20px; } .photos-btn { font-size: 16px; color: #333; margin-bottom: -4px; padding: 5px 8px 3px; } .photos-btn.active { color: #08c; border: 1px solid #e5e5e5; border-bottom: 5px solid #fff; } @media screen and (max-width:600px) { .instagram .thumb { width: 50%; padding-bottom: 50%; } .instagram .album li { width: 100%; position: relative; padding-bottom: 100%; text-align: center; } .instagram .album div.img-box{ margin: 0; width: 90%; height: 90%; } }"},{"title":"书单","date":"2018-05-03T13:31:25.728Z","updated":"2018-05-03T07:58:30.596Z","comments":false,"path":"books/index.html","permalink":"https://wonderxiao.github.io/books/index.html","excerpt":"","text":""},{"title":"","date":"2018-05-04T13:23:50.882Z","updated":"2017-10-12T11:01:05.000Z","comments":true,"path":"album/ins.js","permalink":"https://wonderxiao.github.io/album/ins.js","excerpt":"","text":"/******/ (function(modules) { // webpackBootstrap /******/ // The module cache /******/ var installedModules = {}; /******/ /******/ // The require function /******/ function __webpack_require__(moduleId) { /******/ /******/ // Check if module is in cache /******/ if (installedModules[moduleId]) /******/ return installedModules[moduleId].exports; /******/ /******/ // Create a new module (and put it into the cache) /******/ var module = installedModules[moduleId] = { /******/ exports: {}, /******/ id: moduleId, /******/ loaded: false /******/ }; /******/ /******/ // Execute the module function /******/ modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); /******/ /******/ // Flag the module as loaded /******/ module.loaded = true; /******/ /******/ // Return the exports of the module /******/ return module.exports; /******/ } /******/ /******/ /******/ // expose the modules object (__webpack_modules__) /******/ __webpack_require__.m = modules; /******/ /******/ // expose the module cache /******/ __webpack_require__.c = installedModules; /******/ /******/ // __webpack_public_path__ /******/ __webpack_require__.p = \"/dist/\"; /******/ /******/ // Load entry module and return exports /******/ return __webpack_require__(0); /******/ }) /************************************************************************/ /******/ ([ /* 0 */ /***/ function(module, exports, __webpack_require__) { 'use strict'; __webpack_require__(1); var _view = __webpack_require__(2); var _view2 = _interopRequireDefault(_view); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; } /** * @name impush-client * @description 这个项目让我发家致富… * @date 2016-12-1 */ var _collection = []; var _count = 0; var searchData; function addMask(elem) { var rect = elem.getBoundingClientRect(); var style = getComputedStyle(elem, null); var mask = document.createElement('i'); mask.className = 'icon-film'; mask.style.color = '#fff'; mask.style.fontSize = '26px'; mask.style.position = 'absolute'; mask.style.right = '10px'; mask.style.bottom = '10px'; mask.style.zIndex = 1; elem.parentNode.appendChild(mask); } var createVideoIncon = function createVideoIncon() { var $videoImg = document.querySelectorAll('.thumb a[data-type=\"video\"]'); for (var i = 0, len = $videoImg.length; i < len; i++) { addMask($videoImg[i]); } }; var render = function render(res) { var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j < len2; j++) { var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i < len; i++) { var minSrc = 'https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '\\ \\ \\ \\ ' + data.text[i] + '\\ '; } ulTmpl = ulTmpl + '' + data.year + '年' + data.month + '月\\ ' + liTmpl + '\\ '; } document.querySelector('.instagram').innerHTML = '' + ulTmpl + ''; createVideoIncon(); _view2.default.init(); }; var replacer = function replacer(str) { var arr = str.split(\"/\"); return \"/assets/ins/\" + arr[arr.length - 1]; }; var ctrler = function ctrler(data) { var imgObj = {}; for (var i = 0, len = data.length; i < len; i++) { var y = data[i].y; var m = data[i].m; var src = replacer(data[i].src); var text = data[i].text; var key = y + \"\" + ((m + \"\").length == 1 ? \"0\" + m : m); if (imgObj[key]) { imgObj[key].srclist.push(src); imgObj[key].text.push(text); } else { imgObj[key] = { year: y, month: m, srclist: [src], text: [text] }; } } render(imgObj); }; function loadData(success) { if (!searchData) { var xhr = new XMLHttpRequest(); xhr.open('GET', './data.json?t=' + +new Date(), true); xhr.onload = function() { if (this.status >= 200 && this.status < 300) { var res = JSON.parse(this.response); searchData = res; success(searchData); } else { console.error(this.statusText); } }; xhr.onerror = function() { console.error(this.statusText); }; xhr.send(); } else { success(searchData); } } var Ins = { init: function init() { loadData(function(data) { render(data); }); } }; Ins.init(); // export default impush; /***/ }, /* 1 */ /***/ function(module, exports, __webpack_require__) { /* WEBPACK VAR INJECTION */ (function(global) { 'use strict'; var inViewport = __webpack_require__(3); var lazyAttrs = ['data-src']; global.lzld = lazyload(); // Provide libs using getAttribute early to get the good src // and not the fake data-src replaceGetAttribute('Image'); replaceGetAttribute('IFrame'); function registerLazyAttr(attr) { if (indexOf.call(lazyAttrs, attr) === -1) { lazyAttrs.push(attr); } } function lazyload(opts) { opts = merge({ 'offset': 333, 'src': 'data-src', 'container': false }, opts || {}); if (typeof opts.src === 'string') { registerLazyAttr(opts.src); } var elts = []; function show(elt) { var src = findRealSrc(elt); if (src) { elt.src = src; } elt.setAttribute('data-lzled', true); elts[indexOf.call(elts, elt)] = null; } function findRealSrc(elt) { if (typeof opts.src === 'function') { return opts.src(elt); } return elt.getAttribute(opts.src); } function register(elt) { elt.onload = null; elt.removeAttribute('onload'); elt.onerror = null; elt.removeAttribute('onerror'); if (indexOf.call(elts, elt) === -1) { inViewport(elt, opts, show); } } return register; } function replaceGetAttribute(elementName) { var fullname = 'HTML' + elementName + 'Element'; if (fullname in global === false) { return; } var original = global[fullname].prototype.getAttribute; global[fullname].prototype.getAttribute = function(name) { if (name === 'src') { var realSrc; for (var i = 0, max = lazyAttrs.length; i < max; i++) { realSrc = original.call(this, lazyAttrs[i]); if (realSrc) { break; } } return realSrc || original.call(this, name); } // our own lazyloader will go through theses lines // because we use getAttribute(opts.src) return original.call(this, name); }; } function merge(defaults, opts) { for (var name in defaults) { if (opts[name] === undefined) { opts[name] = defaults[name]; } } return opts; } // http://webreflection.blogspot.fr/2011/06/partial-polyfills.html function indexOf(value) { for (var i = this.length; i-- && this[i] !== value;) {} return i; } module.exports = lazyload; // export default impush; /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ }, /* 2 */ /***/ function(module, exports) { 'use strict'; var initPhotoSwipeFromDOM = function initPhotoSwipeFromDOM(gallerySelector) { // parse slide data (url, title, size ...) from DOM elements // (children of gallerySelector) var parseThumbnailElements = function parseThumbnailElements(el) { el = el.parentNode.parentNode; var thumbElements = el.getElementsByClassName('thumb'), numNodes = thumbElements.length, items = [], figureEl, linkEl, size, type, // video or not target, item; for (var i = 0; i < numNodes; i++) { figureEl = thumbElements[i]; // // include only element nodes if (figureEl.nodeType !== 1) { continue; } linkEl = figureEl.children[0]; // size = linkEl.getAttribute('data-size').split('x'); type = linkEl.getAttribute('data-type'); target = linkEl.getAttribute('data-target'); // create slide object item = { src: linkEl.getAttribute('href'), w: parseInt(size[0], 10), h: parseInt(size[1], 10) }; if (figureEl.children.length > 1) { item.title = figureEl.children[1].innerHTML; } if (linkEl.children.length > 0) { item.msrc = linkEl.children[0].getAttribute('src'); item.type = type; item.target = target; item.html = ''; if (type === 'video') { //item.src = null; } } item.el = figureEl; // save link to element for getThumbBoundsFn items.push(item); } return items; }; // find nearest parent element var closest = function closest(el, fn) { return el && (fn(el) ? el : closest(el.parentNode, fn)); }; // triggers when user clicks on thumbnail var onThumbnailsClick = function onThumbnailsClick(e) { e = e || window.event; e.preventDefault ? e.preventDefault() : e.returnValue = false; var eTarget = e.target || e.srcElement; // find root element of slide var clickedListItem = closest(eTarget, function(el) { return el.tagName && el.tagName.toUpperCase() === 'FIGURE'; }); if (!clickedListItem) { return; } // find index of clicked item by looping through all child nodes // alternatively, you may define index via data- attribute var clickedGallery = clickedListItem.parentNode, // childNodes = clickedListItem.parentNode.childNodes, // numChildNodes = childNodes.length, childNodes = document.getElementsByClassName('thumb'), numChildNodes = childNodes.length, nodeIndex = 0, index; for (var i = 0; i < numChildNodes; i++) { if (childNodes[i].nodeType !== 1) { continue; } if (childNodes[i] === clickedListItem) { index = nodeIndex; break; } nodeIndex++; } if (index >= 0) { // open PhotoSwipe if valid index found openPhotoSwipe(index, clickedGallery); } return false; }; // parse picture index and gallery index from URL (#&pid=1&gid=2) var photoswipeParseHash = function photoswipeParseHash() { var hash = window.location.hash.substring(1), params = {}; if (hash.length < 5) { return params; } var vars = hash.split('&'); for (var i = 0; i < vars.length; i++) { if (!vars[i]) { continue; } var pair = vars[i].split('='); if (pair.length < 2) { continue; } params[pair[0]] = pair[1]; } if (params.gid) { params.gid = parseInt(params.gid, 10); } return params; }; var openPhotoSwipe = function openPhotoSwipe(index, galleryElement, disableAnimation, fromURL) { var pswpElement = document.querySelectorAll('.pswp')[0], gallery, options, items; items = parseThumbnailElements(galleryElement); // define options (if needed) options = { // define gallery index (for URL) galleryUID: galleryElement.getAttribute('data-pswp-uid'), getThumbBoundsFn: function getThumbBoundsFn(index) { // See Options -> getThumbBoundsFn section of documentation for more info var thumbnail = items[index].el.getElementsByTagName('img')[0], // find thumbnail pageYScroll = window.pageYOffset || document.documentElement.scrollTop, rect = thumbnail.getBoundingClientRect(); return { x: rect.left, y: rect.top + pageYScroll, w: rect.width }; } }; // PhotoSwipe opened from URL if (fromURL) { if (options.galleryPIDs) { // parse real index when custom PIDs are used // http://photoswipe.com/documentation/faq.html#custom-pid-in-url for (var j = 0; j < items.length; j++) { if (items[j].pid == index) { options.index = j; break; } } } else { // in URL indexes start from 1 options.index = parseInt(index, 10) - 1; } } else { options.index = parseInt(index, 10); } // exit if index not found if (isNaN(options.index)) { return; } if (disableAnimation) { options.showAnimationDuration = 0; } // Pass data to PhotoSwipe and initialize it gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, options); gallery.init(); var $tempVideo; var stopVideoHandle = function stopVideoHandle() { if ($tempVideo) { $tempVideo.remove(); $tempVideo = null; } }; var changeHandle = function changeHandle() { var item = gallery.currItem; stopVideoHandle(); if (item.type === 'video') { var $ctn = item.container; var style = $ctn.getElementsByClassName('pswp__img')[0].style; var $video = document.createElement('video'); $video.setAttribute('autoplay', 'autoplay'); $video.setAttribute('controls', 'controls'); $video.setAttribute('src', item.target); $video.style.width = style.width; $video.style.height = style.height; $video.style.position = 'absolute'; $video.style.zIndex = 2; $tempVideo = $video; $ctn.appendChild($video); } }; gallery.listen('initialZoomIn', changeHandle); gallery.listen('afterChange', changeHandle); gallery.listen('initialZoomOut', stopVideoHandle); }; // loop through all gallery elements and bind events var galleryElements = document.querySelectorAll(gallerySelector); for (var i = 0, l = galleryElements.length; i < l; i++) { galleryElements[i].setAttribute('data-pswp-uid', i + 1); galleryElements[i].onclick = onThumbnailsClick; } // Parse URL and open gallery if it contains #&pid=3&gid=1 var hashData = photoswipeParseHash(); if (hashData.pid && hashData.gid) { openPhotoSwipe(hashData.pid, galleryElements[hashData.gid - 1], true, true); } }; var Viewer = function() { function init() { initPhotoSwipeFromDOM('.photos'); } return { init: init }; }(); module.exports = Viewer; /***/ }, /* 3 */ /***/ function(module, exports) { /* WEBPACK VAR INJECTION */ (function(global) { module.exports = inViewport; var instances = []; var supportsMutationObserver = typeof global.MutationObserver === 'function'; function inViewport(elt, params, cb) { var opts = { container: global.document.body, offset: 0 }; if (params === undefined || typeof params === 'function') { cb = params; params = {}; } var container = opts.container = params.container || opts.container; var offset = opts.offset = params.offset || opts.offset; for (var i = 0; i < instances.length; i++) { if (instances[i].container === container) { return instances[i].isInViewport(elt, offset, cb); } } return instances[ instances.push(createInViewport(container)) - 1 ].isInViewport(elt, offset, cb); } function addEvent(el, type, fn) { if (el.attachEvent) { el.attachEvent('on' + type, fn); } else { el.addEventListener(type, fn, false); } } function debounce(func, wait, immediate) { var timeout; return function() { var context = this, args = arguments; var callNow = immediate && !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); function later() { timeout = null; if (!immediate) func.apply(context, args); } }; } // https://github.com/jquery/sizzle/blob/3136f48b90e3edc84cbaaa6f6f7734ef03775a07/sizzle.js#L708 var contains = function() { if (!global.document) { return true; } return global.document.documentElement.compareDocumentPosition ? function(a, b) { return !!(a.compareDocumentPosition(b) & 16); } : global.document.documentElement.contains ? function(a, b) { return a !== b && (a.contains ? a.contains(b) : false); } : function(a, b) { while (b = b.parentNode) { if (b === a) { return true; } } return false; }; } function createInViewport(container) { var watches = createWatches(); var scrollContainer = container === global.document.body ? global : container; var debouncedCheck = debounce(watches.checkAll(watchInViewport), 15); addEvent(scrollContainer, 'scroll', debouncedCheck); if (scrollContainer === global) { addEvent(global, 'resize', debouncedCheck); } if (supportsMutationObserver) { observeDOM(watches, container, debouncedCheck); } // failsafe check, every 200ms we check for visible images // usecase: a hidden parent containing eleements // when the parent becomes visible, we have no event that the children // became visible setInterval(debouncedCheck, 150); function isInViewport(elt, offset, cb) { if (!cb) { return isVisible(elt, offset); } var remote = createRemote(elt, offset, cb); remote.watch(); return remote; } function createRemote(elt, offset, cb) { function watch() { watches.add(elt, offset, cb); } function dispose() { watches.remove(elt); } return { watch: watch, dispose: dispose }; } function watchInViewport(elt, offset, cb) { if (isVisible(elt, offset)) { watches.remove(elt); cb(elt); } } function isVisible(elt, offset) { if (!contains(global.document.documentElement, elt) || !contains(global.document.documentElement, container)) { return false; } // Check if the element is visible // https://github.com/jquery/jquery/blob/740e190223d19a114d5373758127285d14d6b71e/src/css/hiddenVisibleSelectors.js if (!elt.offsetWidth || !elt.offsetHeight) { return false; } var eltRect = elt.getBoundingClientRect(); var viewport = {}; if (container === global.document.body) { viewport = { top: -offset, left: -offset, right: global.document.documentElement.clientWidth + offset, bottom: global.document.documentElement.clientHeight + offset }; } else { var containerRect = container.getBoundingClientRect(); viewport = { top: containerRect.top - offset, left: containerRect.left - offset, right: containerRect.right + offset, bottom: containerRect.bottom + offset }; } // The element must overlap with the visible part of the viewport var visible = ( (eltRect.right > viewport.left) && (eltRect.left < viewport.right) && (eltRect.bottom > viewport.top) && (eltRect.top < viewport.bottom) ); return visible; } return { container: container, isInViewport: isInViewport }; } function createWatches() { var watches = []; function add(elt, offset, cb) { if (!isWatched(elt)) { watches.push([elt, offset, cb]); } } function remove(elt) { var pos = indexOf(elt); if (pos !== -1) { watches.splice(pos, 1); } } function indexOf(elt) { for (var i = watches.length - 1; i >= 0; i--) { if (watches[i][0] === elt) { return i; } } return -1; } function isWatched(elt) { return indexOf(elt) !== -1; } function checkAll(cb) { return function() { for (var i = watches.length - 1; i >= 0; i--) { cb.apply(this, watches[i]); } }; } return { add: add, remove: remove, isWatched: isWatched, checkAll: checkAll }; } function observeDOM(watches, container, cb) { var observer = new MutationObserver(watch); var filter = Array.prototype.filter; var concat = Array.prototype.concat; observer.observe(container, { childList: true, subtree: true, // changes like style/width/height/display will be catched attributes: true }); function watch(mutations) { // some new DOM nodes where previously watched // we should check their positions if (mutations.some(knownNodes) === true) { setTimeout(cb, 0); } } function knownNodes(mutation) { var nodes = concat.call([], Array.prototype.slice.call(mutation.addedNodes), mutation.target ); return filter.call(nodes, watches.isWatched).length > 0; } } /* WEBPACK VAR INJECTION */ }.call(exports, (function() { return this; }()))) /***/ } /******/ ]);"},{"title":"分类","date":"2018-05-03T13:33:42.331Z","updated":"2018-05-03T07:58:30.597Z","comments":false,"path":"categories/index.html","permalink":"https://wonderxiao.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-05-03T13:34:11.956Z","updated":"2018-05-03T07:58:30.598Z","comments":true,"path":"links/index.html","permalink":"https://wonderxiao.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2018-05-03T13:30:31.662Z","updated":"2018-05-03T07:58:30.599Z","comments":false,"path":"repository/index.html","permalink":"https://wonderxiao.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-05-04T13:01:48.878Z","updated":"2018-05-04T13:01:48.878Z","comments":false,"path":"tags/index.html","permalink":"https://wonderxiao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GDB调试工具","slug":"GDB调试工具","date":"2018-05-05T10:02:59.000Z","updated":"2018-05-05T02:37:27.850Z","comments":true,"path":"2018/05/05/GDB调试工具/","link":"","permalink":"https://wonderxiao.github.io/2018/05/05/GDB调试工具/","excerpt":"","text":"介绍GDB是GNU开源组织发布的、在UNIX/Linux操作系统下，基于命令行的调试工具。 1. 启动gdb 对于C/C++程序的调试，需在编译前添加-g选项： 1$ g++ -g hello.cpp -o hello 调试可执行文件： 1$ gdb &lt;program&gt; program为可执行文件，一般在当前目录下。 调试core文件(core是程序非法执行错误后，core dump产生的文件) 12$ gdb &lt;program&gt; &lt;core dump file&gt;$ gdb program core.11127 调试服务程序 12$ gdb &lt;program&gt; &lt;PID&gt;$ gdb hello 11127 若程序为一个服务程序，那么可指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试它，program应该在PATH环境变量中搜索得到。 2. gdb交互命令启动gdb后，进入交互模式，通过以下命令完成对程序的调试。其中，有些命令可进行缩写。 运行 run : 简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令 continue （简写c ）：继续执行，到下一个断点处（或运行结束） next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内 step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的 until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体 until+行号： 运行至某行，不仅仅用来跳出循 finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息 call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55) quit：简记为 q ，退出gdb 设置断点 break n （简写b n）:在第n行处设置断点（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578） break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button delete 断点号n：删除第n个断点 disable 断点号n：暂停第n个断点 enable 断点号n：开启第n个断点 clear 行号n：清除第n行的断点 info b （info breakpoints） ：显示当前程序的断点设置情况 delete breakpoints：清除所有断点 查看源代码 list : 简记为 l ，其作用就是列出程序的源代码，默认每次显示10行 list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12 list 函数名：将显示“函数名”所在函数的源代码，如：list main list ：不带参数，将接着上一次 list 命令的，输出下边的内容 打印表达式 print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。 print a：将显示整数 a 的值 print ++a：将把 a 中的值加1,并显示出来 print name：将显示字符串 name 的值 print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数 print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数 display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a whatis ：查询变量或函数 info function： 查询函数 扩展info locals： 显示当前堆栈页的所有变量 查询运行信息 where/bt : 当前运行的堆栈列表 bt backtrace : 显示当前调用堆栈 up/down : 改变堆栈显示的深度 set args : 指定运行时的参数 show args : 查看设置好的参数 info program : 查看程序是否在运行及进程号和被暂停的原因 分割窗口 layout : 分割窗口，可以一边看代码，一边调试 layout src : 显示源代码窗口 layout asm : 显示反汇编窗口 layout regs : 显示源代码/反汇编和CPU寄存器窗口 layout split : 显示源代码和反汇编窗口 Ctrl + L : 刷新窗口","categories":[],"tags":[]},{"title":"位图学习","slug":"位图学习","date":"2018-03-29T09:08:46.000Z","updated":"2018-05-04T13:55:27.149Z","comments":true,"path":"2018/03/29/位图学习/","link":"","permalink":"https://wonderxiao.github.io/2018/03/29/位图学习/","excerpt":"","text":"已知a.txt中有40亿个无符号整数，b.txt中有10000个无符号整数，求交集。可用内存：1G 定义位图法是bitmap的缩写，其指用每一位来存放某种状态，适用于大规模数据，但数据状态不多的情况举例说明： 1unsigned int bit[N]; 在该数组成可存储N*sizeof(int)8个数据，但最大的数只能是Nsizeof(int)*8-1。若存数据范围0~15，则使N=1即可数据为【5，12，1，0，4】存入后： 使用范围使用bit数组来表示某些元素是否存在，如8位电话号码等 位图的操作在C++中int类型由4个字节，即32位。当有1000万条不同数据时，我们只需1000万个位来表示，也就是10000000/(8*1024*1024)MB，约为1.25MB1MB=1000KB=10^6B—–百万字节1GB=1000MB=10^9B—–十亿字节1000万条=10^7=(10/8)*10^6 B=1.25MB 使用一个unsigned int类型的数组或向量来表示位图，假定vectora，则第i为可表示为a[i/32]的i%32位（其中，32*N+r=i） i/32使用位移操作：i&gt;&gt;5，i%32使用：i&amp;31 setZero置零操作将位图中第i位置零 1a[i&gt;&gt;5] &amp;= ~(1&lt;&lt;(i&amp;31)); setOne置位操作将位图中的第i位设置为1，即将a[i/32]的第（i%32）位设置为1。 1a[i&gt;&gt;5] |= (1&lt;&lt;(i&amp;31)); getState获取状态操作判断第i位是否为1，得到的值大于0，说明该位值为1，否则为0 1return a[i&gt;&gt;5] &amp;(1&lt;&lt;(i&amp;31)); 实现代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;#define BIT_INT 32#define SHIFT 5#define MASK 0x1f#define N 4294967296unsigned int *a = NULL;void createALL()&#123; a = new unsigned int[1+N/BIT_INT];&#125;void deleteALL()&#123; delete[] a; a = NULL;&#125;void SetAllZero()&#123; memset(a,0,(1+N/BIT_INT)*sizeof(unsigned int));&#125;void setOne(unsigned int i)&#123; a[i &gt;&gt; SHIFT] |= (1&lt;&lt;(i&amp;MASK));&#125;void setZero()&#123; a[i &gt;&gt; SHIFT] &amp;= ~(1&lt;&lt;(i&amp;MASK));&#125;int getState(unsigned int i)&#123; return (a[i &gt;&gt; SHIFT] &amp;(1 &lt;&lt; (i&amp;MASK)));&#125;void setStateFromFile()&#123; ifstream cin(\"a.txt\"); unsigned int n; while(cin&gt;&gt;n)&#123; setOne(n); &#125;&#125;void printCommonNumber()&#123; ifstream cin(\"b.txt\"); unsigned int n; while(cin&gt;&gt;n)&#123; if(1 == getState(n)) cout&lt;&lt;n&lt;&lt;\" \"; &#125; cout&lt;&lt;endl;&#125;int main()&#123; createALL(); SetAllZero(); setStateFromFile(); printCommonNumber(); deleteALL(); return 0;&#125; 函数库实现C++的STL中有bitmap类，它提供了很多方法，详见http://www.cplusplus.com/reference/stl/bitset/ 使用C++的bitset: 1234567891011121314151617#include&lt;iostream&gt;#include&lt;bitset&gt;using namespace std;#define N 10000000bitset&lt;N&gt; b;int main()&#123; int n; while(cin&gt;&gt;n)&#123; b.set(n); &#125; for(int i = 0;i &lt; N;i ++)&#123; if(b.test(i))&#123; cout&lt;&lt;i&lt;&lt;endl; &#125; &#125;&#125; 注意：bitset不能放在main内，否则stack overflow。若要放在main内，要放在main内，要加static或new一个。 位图应用 求字符的所有组合 思路：输入a、b、c,则它们的组合为a,b,c,ab,ac,bc,abc。 假设原有元素有n个，则最终组合为2^n-1个。利用位图思想，假设原有a、b、c三个元素，则1表示取元素，0表示不取。故取a则为001，取ab则为011，而000没有意义，所以共有2^n个结果。这些位图值都是1,2,…,2^n,所以从值1到值2^n-1的输出结果为：001,010,…,111对应观察结果为：a,b,ab,c,ac,bc,abc。因此，循环1~2^n-1，然后输出组合结果即可。 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;void combination(string str) &#123; if (str == \" \") &#123; return; &#125; int len = str.length(); int n = 1 &lt;&lt; len; for (int i = 0;i &lt; n;i++ ) &#123; for (int j = 0;j &lt; len;j ++) &#123; int temp = i; if (temp &amp;(1 &lt;&lt; j)) cout &lt;&lt; str[j]; &#125; cout &lt;&lt; endl; &#125;&#125;int main()&#123; string str = \"abc\"; combination(str); system(\"pause\"); return 0;&#125; bitmap求哈密尔顿距离 问题描述给定N（1&lt;=N&lt;=100000）个五维的点(X1,X2,X3,X4,X5)，求两点X(x1,x2,x3,x4,x5)和Y(y1,y2,y3,y4,y5)使得|x1-y1|+|x2-y2|+|x3-y3|+|x4-y4|+|x5-y5|最大 解题思路 对于任意两点(x1,x2)和(y1,y2) |x1-y1|=max(x1-y1,y1-x1);=&gt;|x1-y1|+|x2-y2|=max{ (x1-y1)+(x2-y2) (x1-y1)-(x2-y2) (y1-x1)+(x2-y2) (y1-x1)-(x2-y2)}; =max{ (x1+x2)-(y1+y2) (x1-x2)-(y1-y2) (-x1+x2)-(-y1+y2) (-x1-x2)-(-y1-y2)}; 通过观察，发现每一对相同元的符号必定相反，如：xi-yi，于是使用bitmap的思想来枚举这些二维的点的x轴和y轴前的正负号，这样可用一个0~3的二进制形式来表示：0表示+号，1表示-号。 对于每个点X和Y的符号，可用A[4]数组存储下来，那么对于点1(x1,y1)和2(x2,y2)两点就可表示为下式一： A[1][0] - A[2][0]A[1][1] - A[2][1]A[1][2] - A[2][2]A[1][3] - A[2][3] 约定X[ij]的下标数字(ij)是二进制，令 X00=x1+x2X01=x1-x2X10=-x1+x2X11=-x1-x2 假设有A-Z共26个点，则result=max{ (A00-B00), (A01-B01), (A10-B10), (A11-B11), (A00-C00), (A01-C01), (A10-C10), (A11-C11), …… (X00-Y00), (X01-Y01), (X10-Y10), (X11-Y11), (Y00-Z00), (Y01-Z01), (Y10-Z10), (Y11-Z11),} 很明显，对上面每一列应用max运算： max(第一列)=max(A00,B00,…,Z00) - min(A00,B00,…,Z00) result=max{max(第一列)，max(第二列) … }; 对每个I(00,01,10,11)，求A[*][I]的最大值max(I)和最小值min(I),然后再求max{max(I)-min(I)} 通俗的理解 先求A[i][I]-A[j][I](I=00,01,10,11)，还原就是先求该等式xi+xj-(yi+yj)的最大值,分解后变成求max(xi+xj)和min(yi+yj)。再求这两个数相差后得到的集合中的最大值即可。 代码实现总结","categories":[{"name":"算法","slug":"算法","permalink":"https://wonderxiao.github.io/categories/算法/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wonderxiao.github.io/tags/C/"},{"name":"位图","slug":"位图","permalink":"https://wonderxiao.github.io/tags/位图/"},{"name":"大数据存储","slug":"大数据存储","permalink":"https://wonderxiao.github.io/tags/大数据存储/"}]},{"title":"网络流量识别","slug":"网络流量识别","date":"2018-03-28T10:08:52.000Z","updated":"2018-05-04T13:53:46.294Z","comments":true,"path":"2018/03/28/网络流量识别/","link":"","permalink":"https://wonderxiao.github.io/2018/03/28/网络流量识别/","excerpt":"","text":"","categories":[{"name":"科研","slug":"科研","permalink":"https://wonderxiao.github.io/categories/科研/"}],"tags":[{"name":"流量识别","slug":"流量识别","permalink":"https://wonderxiao.github.io/tags/流量识别/"},{"name":"算法","slug":"算法","permalink":"https://wonderxiao.github.io/tags/算法/"}]},{"title":"协议栈分析（一）","slug":"协议栈分析（一）","date":"2018-03-24T20:55:09.000Z","updated":"2018-05-04T13:55:19.464Z","comments":true,"path":"2018/03/25/协议栈分析（一）/","link":"","permalink":"https://wonderxiao.github.io/2018/03/25/协议栈分析（一）/","excerpt":"","text":"协议栈在Linux中的位置 OSI七层模型 IP作用 IP是连接传输链路层和传输层额中枢，不仅为数据在系统上下方向上传输，也为机器间在水平方向上进行数据传输，将链路层简称为2层或L2，网络层为3层或L3，传输层为4层或L4 ETH代表以太网功能，是2层功能的具体实现 ARP是2层和3层之间的连接层，可认为是2.5层协议 L2协议包括PPP、SLIP及Ethernet，都为底层传输协议 每一类软件模块都不能独立存在，必须依托系统其他模块的支持才能正常工作。由于协议栈在内核中实现，所以必须弄清楚操作系统是如何支持协议栈的 下图为真实操作系统的协议栈实现通过上图可以知道，在操作系统实现协议栈额过程中，有两个模块很重要——glibc库和INET模块 glibc提供了各种API接口供用户空间程序的系统调用，来告知内核态来进行资源调整、数据传输。不管应用层软件开发，还是嵌入式软件开发，我们使用的malloc函数、strcpy函数都是由该库提供的。同时，网络编程使用的API接口也是该库提供的。 INET它不属于TCP/IP体系必须的一部分，但它提供了访问TCP/IP层的接口，这些接口是在网络初始化时就已注册到socket层，即是我们常说的socket、bind、connect、listen、send和recv等系统接口。这些接口内部不仅支持你上网（如AF_INET），还支持你的应用程序间的通信（如AF_UNIX）或内核与用户之间的通信（AF_NETLINK），甚至一些少见的协议（如AF_IPX），也就是说，通过这一层的实现，来封装我们经常使用的TCP/IP的接口。 系统初始化流程 Linux系统的启动，指从系统加电后直至系统控制台显示“login:”登录提示符为止的系统运行阶段 与该启动流程相关的代码有： ● 四个汇编程序：bootsect.S setup.S head.S entry.S ● init目录下的main函数流程如下图所示： 与内核启动相关的函数需要关注以下几点： 中断系统及调度系统 文件系统初始化 设备管理系统的初始化 网络协议的初始化由于网络系统本身关系到设备、文件系统及任务调度等方面，若这几方面的知识不整明白，那么对协议栈理解就很难了。","categories":[{"name":"linux","slug":"linux","permalink":"https://wonderxiao.github.io/categories/linux/"}],"tags":[{"name":"TCP","slug":"TCP","permalink":"https://wonderxiao.github.io/tags/TCP/"},{"name":"IP","slug":"IP","permalink":"https://wonderxiao.github.io/tags/IP/"},{"name":"Linux","slug":"Linux","permalink":"https://wonderxiao.github.io/tags/Linux/"}]},{"title":"内存分配","slug":"内存分配","date":"2018-03-24T20:41:56.000Z","updated":"2018-05-04T13:50:45.007Z","comments":true,"path":"2018/03/25/内存分配/","link":"","permalink":"https://wonderxiao.github.io/2018/03/25/内存分配/","excerpt":"","text":"内存分配方式 从静态存储区域分配内存在程序编译时就已分配好，这块内存在程序的整个运行期间都存在，如：全局变量，static变量 在栈上创建在执行函数时，函数内局部变量的存储单元都可在栈上创建，函数执行结束时这些存储单元自动释放栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限 从堆上分配，亦称动态内存分配程序在运行时，用malloc或new申请任意多少的内存，程序员自己负责在何时使用free或delete释放内存动态内存的生存期由程序员决定，使用灵活 C语言中内存申请相关的函数 alloca、calloc、malloc、free、realloc、sbrk alloca是向栈申请内存，因此无需释放；malloc分配的内存位于堆中，且没初始化内存的内容。因此，在malloc之后，调用memset来初始化这部分的内存空间 calloc将初始化这部分的内对空间设置为0 realloc对malloc申请的内存进行大小的调整，申请的内存最终通过free来释放 sbrk增加数据段的大小 malloc、calloc和free都是C函数库实现的，与OS无关C函数库内部通过一定的结构来保存当前有多少可用内存，若程序申请的malloc的大小超过库里所留的空间，则将先调用sbrk系统调用来增加可用空间，再进行分配空间 free时，释放的内存并不立即返回给OS，而是保留在内部结构中。 sbrk类似批发，一次性向OS申请大的内存，malloc等类似零售，满足程序运行时需求，这套机制类似缓冲。 基于这套机制开发的原因： ● 系统调用不能支持任意大小的内存分配，有的系统调用只支持固定大小即其倍数的内存申请，这样会造成需使用小内存而申请大内存空间的浪费 ● 系统调用申请内存代价大，涉及用户态到内核态的转换 malloc和calloc分配动态内存空间区别： malloc( )函数有一个参数，即所分配内存空间的大小void *malloc(size_t size);calloc( )函数有两个参数，分别为元素数目和元素大小，参数乘积为要分配的内存空间大小void *calloc(size_t numElements, size_t sizeOfElement);若调用成功，函数malloc( )和calloc( )都将返回所分配的内存空间的首地址 malloc( )不能初始化所分配的内存空间，calloc( )可以若malloc函数分配的内存空间之前没使用过，则每一位可能都是0；但这部分空间曾被分配、释放或重新分配，则可能存留各种各样的数据。换句话说，即使用malloc函数的程序开始时（内存空间没重新分配）能正常运行，但经过一段时间后（内存空间）可能出现问题calloc函数会将所分配的内存空间中的每一位都初始化为0 malloc函数只返回一个对象，而calloc函数会返回一个由某种对象组成的数组。如为数组分配内存空间时，可选用calloc函数 总结： 在calloc函数和malloc函数之间选择时，只需考虑是否初始化所分配的内存空间，而不要考虑函数是否能返回一个数组。因为，尽管malloc并不能返回一个数组，但它所分配的内存空间仍能供一个数组使用 当程序运行中有malloc时，但没有free，会造成内存泄露。由于一部分内存未被使用而又没被free，因此系统认为这部分内存仍在使用，造成不断的向系统申请内存，使系统可用内存不断减少。但是，内存泄露仅仅指程序在运行时，程序退出时，OS将回收所有资源","categories":[{"name":"内存管理","slug":"内存管理","permalink":"https://wonderxiao.github.io/categories/内存管理/"}],"tags":[{"name":"内存分配","slug":"内存分配","permalink":"https://wonderxiao.github.io/tags/内存分配/"}]},{"title":"腾讯电话面试经","slug":"腾讯电话面试经","date":"2018-03-22T09:21:56.000Z","updated":"2018-05-04T13:53:54.424Z","comments":true,"path":"2018/03/22/腾讯电话面试经/","link":"","permalink":"https://wonderxiao.github.io/2018/03/22/腾讯电话面试经/","excerpt":"","text":"首先进行自我介绍！因为刚开始通话时，我已做过自我介绍。所以，在进行自我介绍时，我介绍了一下我做的3个项目。然后，面试官说对第一个项目比较感兴趣，我就开始介绍。介绍完之后，我说到了流量控制，然后面试官问到了netfilter的几个函数。我简要的说有几个函数，然后问我几个函数之间的关系，没了解过，所以没答上来。 之后的一些问题： C++方面的知识：第一个问题是虚函数的作用？在C++上有除了多态特性，还有什么作用？问到了虚函数的析构函数。 函数的显示转换，然后我回答了显示转换和隐式转换 多线程有哪些东西是多线程自己的？如堆栈、寄存器。还有什么，我没回答上来。 内存分配用什么？？我回答的malloc和new,面试官说还有一个，我没回答上来。 网络知识TCP/IP的四次握手，问到了time_wait()函数Linux指令 数据库MySQL的数据结构是啥？ 其他看过和研究过开源源码没？搭建的博客使用的什么语言？之前用过腾讯云的哪些产品？ 还问了一个智力题，有8瓶水，一瓶有毒，小白鼠尝几次才会尝出那杯毒水？一小时后中毒 总结 C++基础知识需要进一步的灵活运用，掌握很多语法的设计思路 读开源代码，写对代码的理解与认识，代码是怎么实现其算法思想的？ 对尝试新应用时，不能只想着怎么会用？要理解其设计模式、架构及怎么表现出来的。如搭建博客后，要弄清楚其实现，使用的语言等。","categories":[{"name":"工作","slug":"工作","permalink":"https://wonderxiao.github.io/categories/工作/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://wonderxiao.github.io/tags/C/"},{"name":"面试","slug":"面试","permalink":"https://wonderxiao.github.io/tags/面试/"}]},{"title":"python中的正则表达式","slug":"python中的正则表达式","date":"2018-01-27T12:27:02.000Z","updated":"2018-05-04T13:52:30.538Z","comments":true,"path":"2018/01/27/python中的正则表达式/","link":"","permalink":"https://wonderxiao.github.io/2018/01/27/python中的正则表达式/","excerpt":"","text":"正则表达式中常用字符含义 普通字符和11个元字符： 普通字符 匹配自身 abc abc . 匹配任意除换行符”\\n”外的字符 a.c abc \\ 转义字符，使后一个字符改变原来的意思 a.c;a\\c a.c;a\\c * 匹配前一个字符0或多次 abc* ab;abc;cc + 匹配一个字符1次或无限次 abc+ abc;abccc ? 匹配一个字符0次或1次 abc? ab;abc ^ 匹配字符串开头，在多行模式中匹配每行的开头 ^abc abc $ 匹配字符串末尾，在多行模式中匹配每行的末尾 abc$ abc &#124; 或，匹配&#124;左右表达式任意一个，从左到右匹配，若&#124;没有包括在（）中，则它的范围是整个正则表达式 abc&#124;def abcdef {} {m}匹配前一个字符m次，{m,n}匹配前一个字符m~n次，若省略n，则匹配m至无限次 ab{1,2}c abc;abbbc [] 字符集，对应的位置可以是字符集中的任意字符，字符集中的字符可逐个列出，也可给出范围，如[abc]或[a-c]，[^abc]表示取反，即非abc。所有特殊字符在字符集都失去其特殊含义，用\\转义恢复其特殊含义 a[bcd]e abe;ace;ade () 被阔起来的表达式作为分组，从表达式左边开始没遇到一个分组的左括号”(“，编号+1，分组表达式作为一个整体，可接数量词。表达式中的&#124;仅在该组有效 (abc){2};a(123&#124;456)c abcabc;a456c 反斜杠作用： 后跟元字符去除特殊功能，如特殊字符转义成普通字符 后跟普通字符实现特殊功能，如预定义字符 引号序列对应字组所匹配的字符串 2.预定义字符集 普通字符 字符含义 abc abc \\d 数字：[0-9] a\\bc a1c \\D 非数字：[^\\d] a\\Dc abc \\s 匹配任何空白字符：[&lt;空格&gt;\\t\\r\\n\\f\\v] a\\sc a c \\w 匹配包括下划线在内的任何字符：[A-Za-z0-9_] a\\wc abc \\W 匹配非字母字符，即匹配特殊字符 a\\Wc a c \\A 仅匹配字符串开头，同^ \\Aabc abc \\Z 仅匹配字符串结尾，同$ abc\\Z abc \\b 匹配\\w和\\W之间，即匹配一个单词边界，也就是单词和空格间的位置，如’er\\b’可匹配’never’中的’er’，但不能匹配’verb’中的’er’ \\babc\\b;a\\b!bc 空格abc;空格a!bc \\B [^\\b] a\\Bbc abc 3.特殊分组用法 普通字符 字符含义 abc abc (?P&lt;name&gt;) 分组除了原有的编号外再指定一个额外的别名 (?P&lt;id&gt;abc){2} abcabc (?P=name) 引用别名为\\的分组匹配到字符串 (?P&lt;id&gt;\\d)abc(?P=id) 1abc15abc5 &lt;number&gt; 引用编号为\\的分组匹配到字符串 (\\d)abc\\1 1abc15abc5 re模块中的常用函数1.compile()编译正则表达式模式，返回一个对象模式格式：re.compile(pattern,flags=0)pattern:编译时用的字符串表达式flags:编译标志位，用于修改正则表达式的匹配方式，如是否区分大小写，多行匹配等。 常用flags: 标志 含义 re.S(DOTALL) 使匹配包括换行在内的所有字符 re.I(IGNORECASE) 使匹配对大小写不敏感 re.L(LOCALE) 做本地化识别(locale-aware)匹配 re.M(MULTILINE) 多行匹配，影响^和$ re.X(VERBOSE) 该标志通过给予灵活的格式以使正则表达式写得更易于被理解 re.U 根据Unicode字符集解析字符，这个标志影响\\w,\\W,\\b,\\B 1234567import rett = \"It is a good and cool day!\"rr = re.compile(r'\\w*oo\\w*')print(rr.findall(tt)) #查找所有包含'oo'的单词执行结果：['good','cool'] match() 决定RE是否在字符串刚开始的位置匹配该方法并不是完全匹配，当pattern结束后，若string还有剩余字符，仍视为成功。若要完全匹配，则在表达式末尾加上边界匹配符’$’格式：re.match(pattern,string,flags=0)123456print(re.match('com','comwww.runcomoob').group())print(re.match('com','Comwww.runcomoob',re.I).group())执行结果：comcom search() 格式：re.search(pattern,string,flags=0)re.search函数会在字符串内查找模式匹配，只要找到第一个匹配然后返回，若字符串没有匹配，则返回None 1234print(re.search('\\dcom','www.4comrunoob.5com').group())执行结果：2com match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法： group() 返回被 RE 匹配的字符串 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串 a.group()返回re整体匹配的字符串， b.group(n,m)返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常 c.groups()返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组 123456789import rea = \"123abc456\"print(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(0)) #123abc456,返回整体print(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(1)) #123print(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(2)) #abcprint(re.search(\"([0-9]*)([a-z]*)([0-9]*)\",a).group(3)) #456#group(1) 列出第一个括号匹配部分#group(2) 列出第二个括号匹配部分#group(3) 列出第三个括号匹配部分 findall()re.findall遍历匹配，可获取字符串中所有匹配的字符串，返回一个列表格式：re.findall(pattern,string,flags=0)12345p = re.compile(r'\\d+')print(p.findall('o1n2m3k4'))执行结果如下：['1', '2', '3', '4'] 123456789import rett = \"Tina is a good girl, she is cool, clever, and so on...\"rr = re.compile(r'\\w*oo\\w*')print(rr.findall(tt))print(re.findall(r'(\\w)*oo(\\w)',tt))#()表示子表达式 执行结果如下：['good', 'cool'][('g', 'd'), ('c', 'l')] finditer()搜索string，返回一个顺序访问每一个匹配结果(Match对象)的迭代器，找到RE匹配的所有子串，并把它们作为一个迭代器返回格式：re.finditer(pattern,string,flags=0) 12345678910111213141516171819iter = re.finditer(r'\\d+','12 drumm44ers drumming, 11 ... 10 ...')for i in iter: print(i) print(i.group()) print(i.span())执行结果如下：&lt;_sre.SRE_Match object; span=(0, 2), match='12'&gt;12(0, 2)&lt;_sre.SRE_Match object; span=(8, 10), match='44'&gt;44(8, 10)&lt;_sre.SRE_Match object; span=(24, 26), match='11'&gt;11(24, 26)&lt;_sre.SRE_Match object; span=(31, 33), match='10'&gt;10(31, 33) split()按照能够匹配的子串将string分割后返回列表，可使用re.split来分割字符串，如re.split(r’\\s+’,text)来将字符串按空格分割成一个单词列表格式：re.split(pattern,string[, maxsplit])maxsplit用于指定最大分割次数，不指定将全部分割 1234print(re.split('\\d+','one1two2three3four4five5'))执行结果如下：['one', 'two', 'three', 'four', 'five', ''] sub()使用re替换string中每一个匹配的子串后返回替换后的字符串格式：re.sub(pattern,repl,string,count) 12345678910111213141516171819import retext = \"JGood is a handsome boy, he is cool, clever, and so on...\"print(re.sub(r'\\s+', '-', text))执行结果如下：JGood-is-a-handsome-boy,-he-is-cool,-clever,-and-so-on...其中第二个函数是替换后的字符串；本例中为'-'第四个参数指替换个数。默认为0，表示每个匹配项都替换``` re.sub还允许使用函数对匹配项的替换进行复杂处理，如re.sub(r'\\s', lambda m:'[' + m.group(0) + ']',text,0)将字符串中的空格' '替换为'[]'``` pythonimport retext = \"JGood is a handsome boy, he is cool, clever, and so on...\"print(re.sub(r'\\s+', lambda m:'['+m.group(0)+']', text,0))执行结果如下：JGood[ ]is[ ]a[ ]handsome[ ]boy,[ ]he[ ]is[ ]cool,[ ]clever,[ ]and[ ]so[ ]on... subn()返回替换次数格式：subn(pattern,repl,string,count=0,flags=0) 12345678print(re.subn('[1-2]','A','123456abcdef'))print(re.sub(\"g.t\",\"have\",'I get A, I got B ,I gut C'))print(re.subn(\"g.t\",\"have\",'I get A, I got B ,I gut C'))执行结果如下：('AA3456abcdef', 2)I have A, I have B ,I have C('I have A, I have B ,I have C', 3) re.match与re.search与re.findall区别：re.match只匹配字符串的开始，如字符串开始不符合正则表达式，则匹配失败，函数返回None;re.search匹配整个字符串，直到找到一个匹配 1234567891011a=re.search('[\\d]',\"abc33\").group()print(a)p=re.match('[\\d]',\"abc33\")print(p)b=re.findall('[\\d]',\"abc33\")print(b)执行结果：3None['3', '3'] 贪婪匹配与非贪婪匹配*?,+?,??,{m,n}?前面*,+,?等都是贪婪匹配，即尽可能匹配，后面加?号使其变成惰性匹配12345678a = re.findall(r\"a(\\d+?)\",'a23b')print(a)b = re.findall(r\"a(\\d+)\",'a23b')print(b)执行结果：['2']['23'] 12345678a = re.match('&lt;(.*)&gt;','&lt;H1&gt;title&lt;H1&gt;').group()print(a)b = re.match('&lt;(.*?)&gt;','&lt;H1&gt;title&lt;H1&gt;').group()print(b)执行结果：&lt;H1&gt;title&lt;H1&gt;&lt;H1&gt; 123456789a = re.findall(r\"a(\\d+)b\",'a3333b')print(a)b = re.findall(r\"a(\\d+?)b\",'a3333b')print(b)执行结果如下：['3333']['3333']若前后均有限定条件的时候，就不存在什么贪婪模式了，非匹配模式失效 用flags时应注意：1234print(re.split('a','1A1a2A3',re.I))#输出结果并未能区分大小写#re.split(pattern，string，maxsplit,flags)默认是四个参数当我们传入的三个参数的时候，系统会默认re.I是第三个参数，所以就没起作用如果想让这里的re.I起作用，写成flags=re.I即可 实践 匹配电话号码 12p = re.compile(r'\\d&#123;3&#125;-\\d&#123;6&#125;')print(p.findall('010-628888')) 匹配IP12re.search(r\"(([01]?\\d?\\d|2[0-4]\\d|25[0-5])\\.)&#123;3&#125;([01]?\\d?\\d|2[0-4]\\d|25[0-5]\\.)\",\"192.168.1.1\")","categories":[{"name":"python","slug":"python","permalink":"https://wonderxiao.github.io/categories/python/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://wonderxiao.github.io/tags/正则表达式/"},{"name":"python","slug":"python","permalink":"https://wonderxiao.github.io/tags/python/"}]},{"title":"python字符串","slug":"python字符串","date":"2018-01-11T19:37:26.000Z","updated":"2018-05-04T13:52:16.548Z","comments":true,"path":"2018/01/12/python字符串/","link":"","permalink":"https://wonderxiao.github.io/2018/01/12/python字符串/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"https://wonderxiao.github.io/categories/python/"}],"tags":[]},{"title":"NEXX WT3020F路由器刷机","slug":"NEXX-WT3020F路由器刷机","date":"2017-12-22T21:03:01.000Z","updated":"2018-05-04T13:54:15.172Z","comments":true,"path":"2017/12/23/NEXX-WT3020F路由器刷机/","link":"","permalink":"https://wonderxiao.github.io/2017/12/23/NEXX-WT3020F路由器刷机/","excerpt":"","text":"NEXX WT3020F介绍 小型mini路由器 使用MediaTek MT7620n芯片 一个WAN端口、一个LAN端口 802.11n 2T/2R 2.4GHz 300Mbps无线接入 支持3G/4G接入 12345678910111213141516171819/bin# cat /proc/cpuinfosystem type : MediaTek MT7620N ver:2 eco:6machine : Nexx WT3020processor : 0cpu model : MIPS 24KEc V5.0BogoMIPS : 385.84wait instruction : yesmicrosecond timers : yestlb_entries : 32extra interrupt vector : yeshardware watchpoint : yes, count: 4, address/irw mask: [0x0ffc, 0x0ffc, 0x0ffb, 0x0ffb]isa : mips1 mips2 mips32r1 mips32r2ASEs implemented : mips16 dspshadow register sets : 1kscratch registers : 0package : 0core : 0VCED exceptions : not availableVCEI exceptions : not available 刷OpenWrt固件 连接路由器使用secureCRT通过telnet连接到路由器后台，该连接中网络端口需连LAN口1234$ telnet 192.168.8.1(none) login: nexxadminPassword:y1n2inc.com0755 之后，就可在路由器上进行操作管理 备份官方固件 查看当前系统分区信息 123456# cat /proc/mtddev: size erasesize namemtd0: 00030000 00010000 \"Bootloader\"mtd1: 00010000 00010000 \"Config\"mtd2: 00010000 00010000 \"Factory\"mtd3: 007b0000 00010000 \"Kernel\" 将mtd0~mtd3都备份到U盘中 12345# cd /media/sda/sda4cp /dev/mtd0 &gt; mtd0.bincp /dev/mtd1 &gt; mtd1.bincp /dev/mtd2 &gt; mtd2.bincp /dev/mtd3 &gt; mtd3.bin 备份好之后，就可开始进行固件刷入了 OpenWrt固件刷入本人使用WT3020F Fireware Openwrt Install安装包进行固件刷入 按上述链接下载固件二进制文件 使用电脑连接WLAN或通过LAN连接到路由器 打开浏览器输入”192.168.8.1”，用户名：admin，密码：admin 进入高级设置-&gt;配置管理-&gt;软件升级 选择刚下载好的固件二进制文件，进行升级 一段时间后，可看到系统重启，需重新连接路由器 此时，通过”192.168.1.1”，发现并登录不了路由器的WEB界面？？怎么办？当刷完路由器固件后，使用SSH或TTL终端能接入路由器，这时需要安装WEB管理界面LuCY 打开路由器linux终端，输入：opkg update 开始下载Packages.gz并更新 输入：opkg install luci 安装LuCY主体，先开始自动下载各种关联库，下载完会自动安装配置； 输入：/etc/init.d/uhttpd enable 打开uhttpd服务； 输入：/etc/init.d/uhttpd start 让uhttpd自启动； 在电脑端中国浏览器上输入”192.168.1.1”，可访问路由器就表示LuCY安装成功 原来的编译的luci是没有这个挂载点的，如下命令增加挂载点：opkg updateopkg install block-mount重启路由即可出现 挂载点","categories":[{"name":"路由器","slug":"路由器","permalink":"https://wonderxiao.github.io/categories/路由器/"}],"tags":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://wonderxiao.github.io/tags/OpenWrt/"},{"name":"备份，升级","slug":"备份，升级","permalink":"https://wonderxiao.github.io/tags/备份，升级/"}]},{"title":"内存四区","slug":"内存四区","date":"2017-11-01T15:33:11.000Z","updated":"2018-05-04T13:50:37.663Z","comments":true,"path":"2017/11/01/内存四区/","link":"","permalink":"https://wonderxiao.github.io/2017/11/01/内存四区/","excerpt":"","text":"定义内存四区包含静态区、代码区、堆区、栈区 静态区 全局变量和静态变量存储在静态区 堆区 malloc的变量放在堆区，堆区一般由程序员分配释放。若程序员不释放，程序结束时可由操作系统回收。其分配方式类似于链表，在内存中的分布不是连续的，它们是不同区域的内存块通过指针链接起来的。一旦某一节点从链中断开，我们就要人为的将断开的节点从内存中释放。 堆的增长方式由低地址向高地址 栈区 局部变量存在栈区，由编译器自动分配释放，存放函数的参数值、局部变量的值。其操作方式类似数组，它的内存分配是连续分配的，即分配的内存是一块连续的内存区域。当声明变量时，编译器会自动接着当前栈区的结尾继续分配内存。 栈的增长方式由高地址向低地址，函数参数载入时由右向左 常量区 常量字符串存放于此，程序结束后由系统自动释放 代码区 存放函数体的二进制代码一个正常的程序在内存中通常分为程序段、数据段和堆栈三部分。程序段放着程序的机器码、只读数据。这个段通常是只读，对它的写操作是非法的。数据段放的是程序中的静态数据，动态数据则通过堆栈来存放。 内存低端——- 程序段 数据段 堆 栈内存高端——- 堆栈是内存中的一个连续的块，一个叫堆栈指针的寄存器（SP）指向堆栈的栈顶，堆栈的底部是一个固定地址。堆栈有一个特点就是，后进先出。也就是说，后放入的数据第一个取出。它支持两个操作，PUSH和POP。PUSH是将数据放到栈的顶端，POP是将栈顶的数据取出。 在高级语言中，程序函数调用、函数中的临时变量都用到堆栈。为什么呢？因为在调用一个函数时，我们需要对当前的操作进行保护，也为了函数执行后，程序可以正确的找到地方继续执行，所以参数的传递和返回值也用到了堆栈。 通常对局部变量的引用是通过给出它们对SP的偏移量来实现的，另外还有一个基址指针（FP，在Intel芯片中是BP），许多编译器实际上是用它来引用本地变量和参数的。通常，参数的相对FP的偏移是正的，局部变量是负的。 当程序中发生函数调用时，计算机做如下操作：首先把参数压入堆栈；然后保存指令寄存器(IP)中的内容，做为返回地址(RET)；第三个放入堆栈的是基址寄存器(FP)；然后把当前的栈指针(SP)拷贝到FP，做为新的基地址；最后为本地变量留出一定空间，把SP减去适当的数值。 堆和栈的基础知识申请方式 栈系统自动分配，声明局部变量int b;系统自动在栈中为b分配空间 堆程序员自己申请，并指明大小，在C中使用malloc函数，如p1 = (char *)malloc(10);在C++中使用new运算符。但是，p1和p2本身是在栈中存储的。申请后系统的响应 栈只要栈的剩余空间大于所申请的空间，系统就为程序提供内存，否则将异常提示栈溢出 堆在操作系统中，有一个记录空闲内存地址的链表。当系统收到程序申请内存空间时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对大多数系统来说，会在这块内存空间的首地址处记录本次分配的大小。这样，代码中的delete语句才能释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统自动会将多余的那部分重新放入空闲链表中。申请大小的限制 栈在Windows中，栈是向低地址扩展的数据结构，是一块连续的内存区域，即栈顶的地址和栈的最大容量是系统预先规定好的。在Windows下，栈的大小是2M（它是编译时就确定的常数）。若申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。 堆堆是向高地址扩展的数据结构，是不连续的内存区域。由于系统是用链表来存储空闲的内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆得大小受限于计算机系统中有效的虚拟内存。由此可知，堆获得的空间比较灵活，也比较大。申请效率的比较 栈由系统自动分配，速度较快，但程序员无法控制。 堆用户由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便。 在Windows下，最好的方式是用VirtualAlloc分配内存，它不在堆，也不在栈，是直接在进程的地址空间中保留一块内存。虽然用起来最不方便，但是速度快，也最灵活。 堆和栈的存储内容 栈在函数调用时，第一个进栈的是主函数中被调函数的下一条可执行语句的地址。然后是函数的各个参数，在大多数C编译器中，参数是由右往左入栈的，接着是函数中的局部变量。其中，静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是函数参数，最后是栈顶指针指向最开始存的地址，即主函数中的下一条指令，程序由该点继续往下执行。 堆一般是在堆得头部用一个字节存放堆得大小，堆中具体内容由程序员安排。存取效率的比较 12char s1[] = \"aaaaaaaa\";char *s2 = \"bbbbb\"; aaaaaaaa是在运行时进行赋值的，bbbbb是在编译时就确定了的。但是，在以后的存取中，在栈上的数组比指针所指向的字符串（如堆）快。 123456789#include&lt;stdio.h&gt;int main()&#123; char a = 1; char c[] = \"123456\"; char *p = \"123456\"; a = c[1]; a = p[1]; return 0;&#125; 对应的汇编：123456710: a = c[1]; 00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh] 0040106A 88 4D FC mov byte ptr [ebp-4],cl 11: a = p[1]; 0040106D 8B 55 EC mov edx,dword ptr [ebp-14h] 00401070 8A 42 01 mov al,byte ptr [edx+1] 00401073 88 45 FC mov byte ptr [ebp-4],al 第一种在读取时直接将字符串中的元素读到寄存器cl中，而第二种则先把指针值读取到edx中，再根据edx读取字符串。 总结 堆和栈的区别：使用栈就如去饭店吃饭，只需点菜（申请内存），付钱并吃（使用），不必做扫尾等工作，好处是快捷，但自由度小；使用堆就如自己做菜，做自己想吃的，自由行大；这里的堆实际指满足堆性质的优先队列的一种数据结构，第一个元素有最高的优先权；栈实际上是满足先进后出的性质的数据结构。","categories":[{"name":"内存管理","slug":"内存管理","permalink":"https://wonderxiao.github.io/categories/内存管理/"}],"tags":[{"name":"内存分配","slug":"内存分配","permalink":"https://wonderxiao.github.io/tags/内存分配/"}]},{"title":"视频直播","slug":"视频直播","date":"2017-10-27T20:41:24.000Z","updated":"2018-05-04T13:53:29.789Z","comments":true,"path":"2017/10/28/视频直播/","link":"","permalink":"https://wonderxiao.github.io/2017/10/28/视频直播/","excerpt":"","text":"整个直播流程分为几个关键步骤： 主播客户端，将本地采集的视频推送到CDN CDN对视频流进行缓存以及转发 观众客户端，拉取CDN中缓存的视频流进行播放CDN技术原理CDN全称为Content Delivery Network，即内容分发网络，是一个策略性部署的整体系统，主要用来解决由于网络带宽小、用户访问量大、网点分布不均与等导致用户访问网站速度慢的问题。从上可看出，通过增加新的一层网络架构，将网站的内容发布到离用户最近的网络节点上。这样，用户就可以就近获取所需内容，解决之前网络拥塞、访问延迟高的问题，提高用户体验。对于直播业务来说，则将Web服务器换成主播客户端，如下图所示。由于视频占用带宽大，与普通Web服务差别较大，这样CDN优势更明显：网络拥塞减少，访问延迟降低，带宽得到更好的控制。CDN直播中常用的流媒体协议 RTMPReal Time Messaging Protocol，是基于TCP，由Adobe公司为Flash播放器和服务器之间音频、视频传输开发的开放协议 HLSHTTP Live Streaming，是基于HTTP的，是Apple公司开放的音视频传输协议 HTTP FLV将RTMP封装在HTTP协议之上的，可以更好的穿透防火墙等 CDN主要包含源站、缓存服务器、智能DNS、客户端等几个主要组成部分。 源站发布内容的原始站点。添加、删除和更改网站的文件，都是在源站上进行的；另外缓存服务器所抓取的对象也全部来自于源站。对于直播来说，源站为主播客户端。 缓存服务器直接提供给用户访问的站点资源，由一台或数台服务器组成；当用户发起访问时，他的访问请求被智能DNS定位到离他较近的缓存服务器。如果用户所请求的内容刚好在缓存里面，则直接把内容返还给用户；如果访问所需的内容没有被缓存，则缓存服务器向邻近的缓存服务器或直接向源站抓取内容，然后再返还给用户。 智能DNS整个CDN技术的核心，它主要根据用户的来源，以及当前缓存服务器的负载情况等，将其访问请求指向离用户比较近且负载较小的缓存服务器。通过智能DNS解析，让用户访问同服务商下、负载较小的服务器，可以消除网络访问慢的问题，达到加速作用。 客户端发起访问的普通用户。对于直播来说，就是观众客户端。对于直播业务，CDN整体架构如下图所示： 主要流程： 主播开始进行直播，向智能DNS发送解析请求； 智能DNS返回最优CDN节点IP地址； 主播端采集音视频数据，发送给CDN节点，CDN节点进行缓存等处理； 观众端要观看此主播的视频，向智能DNS发送解析请求； 智能DNS返回最优CDN节点IP地址； 观众端向CDN节点请求音视频数据； CDN节点同步其他节点的音视频数据； CDN节点将音视频数据发送给观众端； 一提到直播，就会涉及到播放延时的问题，那么为什么会播放延时呢？ 1.网络延时网络延时是指从主播端采集，到观众端播放之间的时间差。这里不考虑主播端采集对视频进行编码的时间及观众端观看视频对解码的时间，仅考虑网络传输中的延时。假设该链路上有缓存，时间应该添加缓存时间。另外，数据传输过程中还涉及到逻辑上的交互，例如包的重传以及确认，以及缓存上的一些逻辑等，会在这个基础上又增加很多。 在节点较少、网络情况较好的情况下，那么网络延时对应也是最小，加上一定的缓存，可以控制延时在1s~2s左右。但是节点多、网络差的情况下，网络延时会对应增大，经验来说延时可以达到15s以上。 2.网络抖动网络抖动，是指数据包的到达顺序、间隔和发出时不一致。比如说，发送100个数据包，每个包间隔1s发出。结果第27个包在传输过程中遇到网络拥塞，造成包27不是紧跟着26到达的，而是延迟到87后面才达。在直播中，这种抖动的效果实际上跟丢包是一样的。因为你不能依照接收顺序把内容播放出来，否则会造成失真。134746网络抖动，会造成播放延时对应增大。如果网络中抖动较大，会造成播放卡顿等现象。具体情况如下图：如上图，主播在t3和t5发出的包，分别在t3’和t5’到达，但中间延时较大，即发生了网络抖动，这样造成观众端观看视频的延时会不断增大。 3.网络丢包CDN直播中用到的RTMP、HLS、HTTP FLV等协议都是在TCP的基础之上。TCP一个很重要的特性是可靠性，即不会发生数据丢失的问题。为了保证可靠性，TCP在传输过程中有3次握手，见下图。首先客户端会向服务端发送连接请求，服务端同意后，客户端会确认这次连接。这就是3次握手。接着，客户端就开始发送数据，每次发送一批数据，得到服务端的“收到”确认后，继续发送下一批。TCP为了保证传到，会有自动重传机制。如果传输中发生了丢包，没有收到对端发出的“收到”信号，那么就会自动重传丢失的包，一直到超时。由于互联网的网络状况是变化的，以及主播端的网络状况是无法控制的。所以当网络中丢包率开始升高时，重传会导致延时会不断增大，甚至导致不断尝试重连等情况，这样不能有效的缓存，严重情况下会导致观众端视频无法观看。 从底层协议和布网结构上，使用基于UDP协议的传输方案。SD-RTN（Software-Defined Real Time Net work），软件定义实时传输网络，是一种新型的专为内容实时传输而设计，基于UDP协议的网络架构。SD-RTN通过在互联网上不同地区的数据中心放置软件组网单元，相互连接互相调度，在现有的公共互联网基础上构建一层新的虚拟网络。能够实时根据各节点的连接、传输状况、负载状况、到用户的距离和响应时间，自动分配最优最通畅的传输路径，达到实时传输需要的质量保障级别。 CDN与SD-RTN对比情况： 基本原理不同CDN是存储转发结构，设计目的是在各个边缘节点缓存待分发内容，结构上从源站到观众是伞状多级缓存放大方式。SD-RTN本质上一个实时传输网络，用户的数据在网络单元内部和传输线路上都以实时交换方式传送，UDP实现的传输协议，不会因为前一个包的丢失或延迟导致下后续包的延迟送达，而丢包可以用对延迟更友好的方式修复或补偿出来，从而能够保证最低延迟。 底层协议不同SD-RTN采用了专为实时传输设计的UDP协议，避免了采用TCP的延时不可控缺点。能够大大缩短交互延时，延时可从CDN方案的数秒，降低到数百毫秒。 内容分发机制不同SD-RTN是基于自定义路由，选择最优传输路径，直接将内容端到端传输，数据在网络单元中从不缓存，从而最大可能的降低延迟，同时内容安全性也更好。CDN是将内容缓存于缓存服务器中，再将内容就近下发，所以CDN更适合做内容分发，一对多的场景。 使用场景不同SD-RTN适用于要求极低时延的实时互动场景，例如网络电话、视频会议、有主播与观众交互需求的互动直播等。CDN适用于对时延要求不高的场景，例如对延时要求不高、类似电视的单点直播、网站加速等。SD-RTN的优势 时延大大缩短直播延时可从基于TCP的方案的数秒，降低到数百毫秒。这一延迟范围，属于实时通信或准实时通信延迟的范畴。在这一级别上，主播和观众可以基本重现在现场活动中的交互体验，从而大大释放了内容制作者的潜力，也为业务运营者创造新业务形式打开了无限的空间和可能。 抗丢包能力强SD-RTN中可以针对用户网络使用更多的策略模型和技术，这样在30%丢包时，依然能够进行正常直播。而基于TCP的直播方案在丢包2%时就明显卡顿，达到30%经常已断开连接，无法进行直播。 直播中若要与用户交互，常见有两种方式： 文字 连麦，主播可面对面与观众进行交互，增加互动性连麦分析 多路RTMP流实现RTMP是目前主播最常用的协议，实现连麦方式若下图：当有连麦者时，则主播端和连麦者端，都分别推一路RTMP流到CDN，CDN再将这两路RTMP流发送给观众端，观众端将两路RTMP流合成为一个画面。这种方式的优点是实现简单，但缺点比较多： 主播与连麦者如果要进行交互，则考虑到上面分析的延时问题，在这里延时需要至少加大一倍，这样对于实时交互来说，完全无法接受； 主播与连麦者交互时，声音会产生干扰，形成回音； 观众端要接收两条视频流，带宽、流量消耗过大，并且两路视频流解码播放，耗费CPU等资源也非常多； 主播端与连麦者P2P主播端与连麦者之间使用P2P方式进行交互，然后主播端将自己和连麦者的视频进行合并，再推到CDN上，CDN再发送给观众端，如下图： 优点主播和连麦者之间使用P2P，网络质量较好，延迟较小，保证了两者之间交互不会有非常大的延时可以解决声音的干扰问题，消除回声 缺点P2P在某些网络下无法穿透，有些观众根本无法与主播端进行交互;主播端需要上传两路视频：一路P2P与连麦者进行交互，一路使用RTMP推到CDN。还要下载一路视频：连麦者P2P发送过来的交互数据。所以主播端要求带宽需要较高，网络较差时无法进行主播;主播端要进行多路视频的编码、解码，要求主播端设备配置比较高，较差的设备也无法进行主播;只能支持一个连麦者，不能支持多个连麦者;由于主播端和连麦者经过CDN合并成一路，因此，不能实现主播端和连麦者视频大小窗口切换。 服务器端合图主播和连麦者都将视频推送到CDN中，然后CDN内部对这几路视频进行合图，再将其发送给观众端。如下图： 优点主播和连麦者各路视频都使用RTMP推送到CDN，可以保证延时较小；由于CDN进行视频合图和发送，所以主播不需要很高的带宽；由于CDN进行视频合图，所以主播的设备不需要配置非常高；没有声音干扰问题；可以支持多个连麦者连麦； 缺点CDN需要进行视频的合图，需要额外开发工作，并且逻辑比较复杂；CDN需要进行视频的合图，需要消耗较高服务器资源；CDN合图后的布局难控制；解决方案使用SD-RTN，可以很好的解决多路RTMP、P2P连麦、服务器端合图这几种方案的弱势，并且开发难度降低，合图布局等都可以很好的在客户端上进行控制。具体SD-RTN的架构可以参考下图：客户端均通过UDP连接SD-RTN架构服务，通过SD-RTN的就近接入策略，让使用者就近接入质量最好的数据节点，经过传输延迟和质量优化的最优路径，自动避免网络拥塞和骨干网络故障的影响，将数据发送给其他客户端。若有常规的长延迟旁路直播，则可以将主播与连麦者合成一路直播流，通过RTMP推到CDN，进行下发。连接这一路的观众，不能参与连麦互动，达到了最佳直播效果。","categories":[{"name":"科研","slug":"科研","permalink":"https://wonderxiao.github.io/categories/科研/"}],"tags":[{"name":"视频","slug":"视频","permalink":"https://wonderxiao.github.io/tags/视频/"}]},{"title":"汇编","slug":"汇编","date":"2017-10-17T16:30:03.000Z","updated":"2018-05-04T13:53:09.542Z","comments":true,"path":"2017/10/18/汇编/","link":"","permalink":"https://wonderxiao.github.io/2017/10/18/汇编/","excerpt":"","text":"说明 反汇编指令使用gdb disas [function-name]objdump -d/-D obj-name对整个程序进行反汇编通过这个反汇编可以发现main函数并非一个程序的入口，而是__start函数 函数调用时入栈的顺序是编译时确定的，函数调用之前需要入栈的主要是函数参数，而参数都是固定，可变参数只是用宏确定偏移量。调用函数的代码放在代码段。入栈是以指令方式进行的，所以都是编译时确定了的。","categories":[{"name":"linux","slug":"linux","permalink":"https://wonderxiao.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wonderxiao.github.io/tags/linux/"},{"name":"汇编","slug":"汇编","permalink":"https://wonderxiao.github.io/tags/汇编/"}]},{"title":"linux内存分配函数","slug":"linux内存分配函数","date":"2017-10-16T16:30:03.000Z","updated":"2018-05-04T13:54:38.231Z","comments":true,"path":"2017/10/17/linux内存分配函数/","link":"","permalink":"https://wonderxiao.github.io/2017/10/17/linux内存分配函数/","excerpt":"","text":"bzero()函数原型：extern void bzero(void *s, int n)用法：#include功能：置字符串s的前n个字节为零且包括’\\0’说明：bzero无返回值，推荐使用memset()代替bzero()函数123456789101112#include &lt;syslib.h&gt;#include &lt;string.h&gt;int main()&#123; struct &#123; int a; char s[5]; float f; &#125; tt; char s[20]; bzero(&amp;tt,sizeof(tt));...&#125; memset()函数原型：extern void memset(void buffer, int c, int count)用法：#include功能：将buffer所指向内存区域的前count个字节置成c说明：返回指向buffer的指针1234567#include &lt;syslib.h&gt;#include &lt;string.h&gt;int main()&#123; char *s=\"Golden Global View\"; clrscr(); memset(s,'G',6);&#125; setmem()函数原型：extern void setmem(void *buf, unsigned int count, char ch)功能：把buf所指内存区域前count个字节设置成字符ch说明：返回指向buf的指针1234567#include &lt;syslib.h&gt;#include &lt;string.h&gt;int main()&#123; char *s=\"Golden Global View\"; clrscr(); setmem(s,6,'G');&#125; 在LINUX平台上是支持bzero的，但是其并不在ANSI C中定义，也就是不属于C的库函数在C/C++ code上1#define bzero(a, b) memset(a, 0, b) 总结在初始化内存空间时，尽量使用memset()函数，由于其属于标准C的库函数，而各方面支持的都好。同时，其返回值是指向需分配的buffer的指针，能够进行很好的参数传递。","categories":[{"name":"linux","slug":"linux","permalink":"https://wonderxiao.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://wonderxiao.github.io/tags/linux/"},{"name":"内存分配","slug":"内存分配","permalink":"https://wonderxiao.github.io/tags/内存分配/"}]},{"title":"类型转换","slug":"类型转换","date":"2017-10-16T16:28:19.000Z","updated":"2018-05-04T13:50:55.878Z","comments":true,"path":"2017/10/17/类型转换/","link":"","permalink":"https://wonderxiao.github.io/2017/10/17/类型转换/","excerpt":"","text":"关于类型转换123456789101112131415161718192021222324int p = 0x12345678;char *t;t = (char *)&amp;p;printf(\"p:0x%x\\n\",&amp;p);printf(\"q[0]:0x%x\\n\",q[0]);printf(\"&amp;q[0]:0x%x\\n\",&amp;q[0]);printf(\"q[1]:0x%x\\n\",q[1]);printf(\"&amp;q[1]:0x%x\\n\",&amp;q[1]);printf(\"q[2]:0x%x\\n\",q[2]);printf(\"&amp;q[2]:0x%x\\n\",&amp;q[2]);printf(\"q[3]:0x%x\\n\",q[3]);printf(\"&amp;q[3]:0x%x\\n\",&amp;q[3]);运行结果：p:0xffffcbc4q[0]:0x78&amp;q[0]:0xffffcbc4q[1]:0x56&amp;q[1]:0xffffcbc5q[2]:0x34&amp;q[2]:0xffffcbc6q[3]:0x12&amp;q[3]:0xffffcbc7 &amp;p本来是int *类型，强制转换为char * 12int a = 10;int *p = &amp;a; int *p表示（int *)p，即指向整型变量的指针变量 p对于a的首地址 p所对内存长度为sizeof(int)个字节 对指针进行强制类型转换时并不改变指针的值，即对应的首地址，但其对应的内存长度会改变。许多编译器对指针类型要求严格，在传递指针时要进行强制类型转换。123int m = 20;float t;t = (float)m; 此时的强制类型转换，会将m处存放的值转化为float型的变量赋给t里的内容。再举一例：123char ch1 = 0x0A; // 假设ch1地址位于20H，即m[20H] = 0x0AHchar* p1 = &amp;ch1;char** pp1 = &amp;p1; 观察下表： variable addr value ch1 20 0A None 21 CC p1 22 20 pp1 23 22 若内存空间可看成一个数组：char m[256]，则1char ch1 = **pp1; 因此，可理解成：1char ch1 = m[m[pp1]]; // 解二级指针引用 同样地，123char ch2 = *p1;可理解成：char ch2 = m[p1];// 解指针引用 在汇编层面，就是按上述叙述理解，比如：12MOV EAX, [EDA + 8]CALL EAX 总结当你想动态分配内存给二维数组，如矩阵、表等的时候，就可以使用(* *)这种二级指针进行操作了。简单地说，二级指针能够修改上一级的指针，就像一级指针能修改其指向的值。同时，二级指针相对于一级指针来说，其减少了函数传参，如需传一个*offset来指示函数调用后的偏移量，而若传二级指针，则在函数调用后，指针就自动直接指向偏移后的地址了。另一方面，二级指针，只是指向的变量换成指针了而已。","categories":[{"name":"内存管理","slug":"内存管理","permalink":"https://wonderxiao.github.io/categories/内存管理/"}],"tags":[{"name":"类型转换","slug":"类型转换","permalink":"https://wonderxiao.github.io/tags/类型转换/"}]},{"title":"网络通信关键函数理解","slug":"网络通信关键函数理解","date":"2017-10-16T16:25:36.000Z","updated":"2018-05-04T13:55:36.337Z","comments":true,"path":"2017/10/17/网络通信关键函数理解/","link":"","permalink":"https://wonderxiao.github.io/2017/10/17/网络通信关键函数理解/","excerpt":"","text":"sockaddr_in当我们调用bind()、connect()等函数时，都需传入一个struct sockaddr *类型指针，用来表明地址信息，即需对哪个IP、哪个端口进行bind或connect操作。这时，我们传给函数关于地址信息的参数会强制转换成sockaddr_in类型的形式，即struct sockaddr是通用的套接字地址形式。在linux环境下，结构体struct sockaddr在/usr/include/linux/socket.h中定义，具体如下：123456typedef unsigned short sa_family_t;struct sockaddr &#123; sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */&#125; sa_family是地址家族，一般以”AF_xxx”形式存在，通常为AF_INET，代表TCP/IP协议簇 sa_data是14字节协议地址 4个字节的无符号整数（IP地址） 2个字节的无符号整数（端口号） 从sockaddr的定义中，无法确定IP地址和端口号在这14个字节地址空间中的存放位置。因此，进行参数传递时，还需知道这14个字节的空间是如何利用，即哪里放IP地址、哪里放端口号、哪里是空白。于是，在此基础上，构造了sockaddr_in的结构体。在linux环境下，结构体struct sockaddr_in在/usr/include/netinet/in.h中定义，具体如下：123456789101112131415161718/* Structure describing an Internet socket address. */struct sockaddr_in&#123; __SOCKADDR_COMMON (sin_family); /* Address family */ in_port_t sin_port; /* Port number. */ struct in_addr sin_addr; /* Internet address. */ /* Pad to size of `struct sockaddr'. */ unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE - sizeof (in_port_t) - sizeof (struct in_addr)]; /* 字符数组sin_zero[8]的存在是为了保证结构体struct sockaddr_in的大小和结构体struct sockaddr的大小相等 */&#125;;typedef unsigned short int sa_family_t;#define __SOCKADDR_COMMON(sa_prefix) \\ sa_family_t sa_prefix##family /*此为整型变量占2字节，主要用于指明地址类型，取值为AF_UNIX|AF_INET|AF_INET6|AF_PACKET等*/ sin_family指代协议族，在socket编程中只能是AF_INET sin_port存储端口号(使用网络字节顺序) sin_addr存储IP地址，使用in_addr这个数据结构 sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节 下面是struct sockaddr_in中用到两个数据类型，具体定义如下：1234567/* Type to represent a port. */typedef uint16_t in_port_t; struct in_addr其实就是32位IP地址struct in_addr &#123; unsigned long s_addr;&#125;; s_addr按照网络字节顺序存储IP地址 struct sockaddr是通用的套接字地址形式 struct sockaddr_in是Internet下套接字的地址形式 sockaddr_in和sockaddr长度均为16字节，是并列结构，指向sockadd_in结构的指针，也可指向sockaddr的结构体。也就是说，你使用sockaddr_in建立你所需要的信息，然后按照函数要求进行类型转换就可以了。比如：12345sockaddr_in mySock;bzero((char *)&amp;mySock,sizeof(mySock));mySock.sa_family = AF_INET;mySock.sin_port = htons(1234);mySock.sin_addr.s_addr = inet_addr(\"192.168.1.1\"); 在一般构建网络通信过程中，需将sockaddr_in结构强制转换成sockaddr结构，再传入系统调用函数中。通常，BSD网络软件中包含了两个函数，用来在二进制地址格式和点分十进制字符串格式之间相互转换，但是这两个函数仅仅支持IPv4。12in_addr_t inet_addr(const char *cp);char *inet_ntoa(struct in_addr in); 功能相似的两个函数同时支持IPv4和IPv612const char *inet_ntop(int domain, const void *addr, char *str, socklen_t size);int inet_pton(int domain, const char *str, void *addr); 通常用法123456789int sockfd;struct sockaddr_in my_addr;sockfd = socket(AF_INET, SOCK_STREAM, 0);my_addr.sin_family = AF_INET;my_addr.sin_port = htons(MYPORT);my_addr.sin_addr.s_addr = inet_addr(\"192.168.1.1\");bzero(&amp;(my_addr.sin_zero), 8));//memset(&amp;(my_addr.sin_zero), 0, 8);bind(sockfd, (struct sockaddr *)&amp;my_addr, sizeof(struct sockaddr)); 总结在进行网络编程时，常常使用的函数如bind()、connect()函数都已定义好。在这些函数传参过程中，需按照参数的标准类型进行传递。而定义struct sockaddr时，往往不能确定网络地址和端口号在内存中的具体存储。于是，使用struct sockaddr_in将存储地址定义清楚。在此之后，由于其结构空间一样，可直接进行类型转换，就如(int )转换成(float )一样。","categories":[{"name":"linux","slug":"linux","permalink":"https://wonderxiao.github.io/categories/linux/"}],"tags":[{"name":"类型转换","slug":"类型转换","permalink":"https://wonderxiao.github.io/tags/类型转换/"},{"name":"socket编程","slug":"socket编程","permalink":"https://wonderxiao.github.io/tags/socket编程/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-16T08:36:21.804Z","updated":"2017-10-11T07:51:46.000Z","comments":true,"path":"2017/10/16/hello-world/","link":"","permalink":"https://wonderxiao.github.io/2017/10/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"GitHub上搭建博客&增加相册功能","slug":"GitHub上搭建博客-增加相册功能","date":"2017-10-12T19:34:26.000Z","updated":"2018-05-04T13:55:09.664Z","comments":true,"path":"2017/10/13/GitHub上搭建博客-增加相册功能/","link":"","permalink":"https://wonderxiao.github.io/2017/10/13/GitHub上搭建博客-增加相册功能/","excerpt":"","text":"目标 在github上成功搭建Hexo博客 实现在博客上浏览图片，添加图片功能 最终效果:https://wonderxiao.github.io/ 说明 使用主题：hexo-theme-yilia来搭建Hexo博客 使用lawlite来增加相册功能，其中必须的样式文件点击必需文件在photos中包含四个文件 index.ejs ins.css ins.js lazyload.min.js 搭建博客 申请github账号 windows系统下使用腾讯管家安装git 安装nodejs 验证软件安装成功123$ git --version #git@2.13.0$ node -v #node@8.6.0$ npm -v #npm@5.3.0 git与github互联实现远程控制 创建repository，新建一个版本库创建的版本库名字设置注意事项如图中所示，即xxx/xxx.github.io 配置SSH key1$ cd ~/.ssh #查看本机是否已存在ssh密钥 若提示：No such file or directory 说明你是第一次使用git 1$ ssh-keygen -t rsa -C \"邮件地址\" 一直回车，若需yes请输入，这是给权限，最终会生成文件在用户目录下，找到.ssh/id_rsa.pub文件，复制文件里的内容。 打开setting，建立本地系统的git bash与github连接权限，具体设置如下图所示： 测试是否成功1$ ssh git@github.com 若如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 使用Hexo博客Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 原理github page存放的都是静态文件，博客不仅存放文章内容，还存放文章列表、分类、标签、分类等动态文件。若每次写文章都去更新博文目录及其相关链接，那会很复杂。故每次写完博客，通过使用hexo来批量处理相关页面的生成，将有改动的内容更新到github上。 安装1$ npm install -g hexo 初始化在电脑上某处新建hexo的文件夹，此文件夹为你存放，如F:\\workBlog\\hexo，然后使用hexo命令进行初始化。12$ cd /f/workBlog/hexo/$ hexo init 这样，hexo会自动下载hexo所需文件，如node_modules等。123$ hexo clean #清除之前产生的内容，如hexo g产生的$ hexo generate #生成$ hexo server #启动服务 hexo server是开启本地预览服务，打开浏览器访问http://localhost:4000，即可看到加载的hexo博客 此阶段遇到的问题本地浏览器加载时出现一直转圈，不能访问此处一般为端口占用，解决方法: 查看电脑中占用端口4000的进程，关闭即可 打开hexo文件夹下_config.yml,将配置中端口port改成未占用的端口即可 上传到github若一切配置到之后，使用hexo deploy发布即可。但需满足: ssh key配置正确 配置hexo目录下_config.yml文件 在_config.yml最后面添加:1234deploy: type: git repository: git@github.com:xxx/xxx.github.io.git branch: master 在此之后，一般出现： Deployer not found: github 或者 Deployer not found: git 这是需要安装插件:1$ npm install hexo-deployer-git --save 之后，进行发布博客后，点击所有文章会出现模块缺失解决方法： node版本升级 npm i hexo-generator-json-content –save 在hexo文件下的_config.yml下添加： 123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: false raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 常用hexo命令1234567hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本 缩写：1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy 写博客1$ hexo new 'my-first-blog' 这时我们新建了my-first-blog.md文件，一般完整格式如下：1234567title: postName #文章页面上的显示名称，一般是中文 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: 默认分类 #分类 tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格 description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 添加相册 github建立一个用于存储相册的版本库，这里建立BlogPicture 和hexo同目录下，将github下新建的BlogPicture克隆到本地文件夹下 在BlogPicture下新建photos，将样式文件放在photos文件夹下，样式文件放在github上： https://github.com/wonderxiao/BlogPicture/tree/master/four修改ins.js文件，主要是更改render函数 其中url对应你放在github上图片的地址，主要是更改src和minSrc 1234567891011121314151617181920212223242526272829var render = function render(res) &#123; var ulTmpl = \"\"; for (var j = 0, len2 = res.list.length; j &lt; len2; j++) &#123; var data = res.list[j].arr; var liTmpl = \"\"; for (var i = 0, len = data.link.length; i &lt; len; i++) &#123; var minSrc = 'https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/min_photos/' + data.link[i]; var src = 'https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/' + data.link[i]; var type = data.type[i]; var target = src + (type === 'video' ? '.mp4' : '.jpg'); src += ''; liTmpl += '&lt;figure class=\"thumb\" itemprop=\"associatedMedia\" itemscope=\"\" itemtype=\"http://schema.org/ImageObject\"&gt;\\ &lt;a href=\"' + src + '\" itemprop=\"contentUrl\" data-size=\"1080x1080\" data-type=\"' + type + '\" data-target=\"' + src + '\"&gt;\\ &lt;img class=\"reward-img\" data-type=\"' + type + '\" data-src=\"' + minSrc + '\" src=\"/assets/img/empty.png\" itemprop=\"thumbnail\" onload=\"lzld(this)\"&gt;\\ &lt;/a&gt;\\ &lt;figcaption style=\"display:none\" itemprop=\"caption description\"&gt;' + data.text[i] + '&lt;/figcaption&gt;\\ &lt;/figure&gt;'; &#125; ulTmpl = ulTmpl + '&lt;section class=\"archives album\"&gt;&lt;h1 class=\"year\"&gt;' + data.year + '年&lt;em&gt;' + data.month + '月&lt;/em&gt;&lt;/h1&gt;\\ &lt;ul class=\"img-box-ul\"&gt;' + liTmpl + '&lt;/ul&gt;\\ &lt;/section&gt;'; &#125; document.querySelector('.instagram').innerHTML = '&lt;div class=\"photos\" itemscope=\"\" itemtype=\"http://schema.org/ImageGallery\"&gt;' + ulTmpl + '&lt;/div&gt;'; createVideoIncon(); _view2.default.init(); &#125;; python脚本文件下载python脚本文件按照我的这种目录进行构建+-BlogPicture&nbsp;&nbsp;&nbsp;&nbsp;+- hexo&nbsp;&nbsp;&nbsp;&nbsp;+- BlogPicture&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; +-four ##四个样式文件&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; +-photos ##存放相册中的相片与python文件 相片文件命名格式——json转换 2017-10-12_时钟.png 最前面的是日期，然后用_分割 后面信息为描述图片信息 注意data.json存储位置及tool.py中src_dir和des_dir路径信息 最后若缩略图不显示，下载empty.png文件再进行重新上传文件即可。 ##效果图：","categories":[{"name":"博客","slug":"博客","permalink":"https://wonderxiao.github.io/categories/博客/"}],"tags":[{"name":"github","slug":"github","permalink":"https://wonderxiao.github.io/tags/github/"},{"name":"相册","slug":"相册","permalink":"https://wonderxiao.github.io/tags/相册/"},{"name":"hexo","slug":"hexo","permalink":"https://wonderxiao.github.io/tags/hexo/"}]},{"title":"互联网分层架构","slug":"互联网分层架构","date":"2017-10-12T09:57:02.000Z","updated":"2018-05-04T13:52:52.412Z","comments":true,"path":"2017/10/12/互联网分层架构/","link":"","permalink":"https://wonderxiao.github.io/2017/10/12/互联网分层架构/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Linux内核学习","slug":"Linux内核学习","date":"2017-10-12T09:08:24.000Z","updated":"2018-05-04T13:54:28.784Z","comments":true,"path":"2017/10/12/Linux内核学习/","link":"","permalink":"https://wonderxiao.github.io/2017/10/12/Linux内核学习/","excerpt":"","text":"本文主要目的是学习并归纳Linux操作系统中内核的几个基本重要知识 进程 一个进程在地址空间中执行一个单独的指令序列 地址空间是允许进程引用的内存空间的集合，操作系统允许具有多个执行流的进程，即在相同的地址空间可执行多个指令序列。进程能并发活动，竞争的系统资源主要是CPU区分程序和进程： 几个进程能并发执行同一个程序，同时，同一进程能顺序执行多个程序 现在的CPU处理器一般都是多核CPU，可通过任务管理器查看。而在单处理器系统上，只有一个进程能占用CPU。因此，在某时刻，只能有一个执行流。CPU有多少个，就有多少个进程可同时执行。选择哪个进程执行由操作系统的调度程序决定，进程分为抢占式进程和非抢占式进程。对于抢占式进程，只有进程自愿放弃CPU，调度程序才会被调用；对于非抢占式进程，如多用户系统中的进程调度，操作系统记录下每个进程占优的CPU时间，并周期性地激活调度程序。 为了标识一个特定的文件，进程使用路径名，路径名由斜杠及一列指向文件的目录名交替组成。若路径名第一个字符是斜杠那么该路径就为绝对路径，因为其起点是根目录。若第一项是目录名或文件名，那么路径就是相对路径，因为其起点是进程的当前目录。 Linux文件与目录操作系统为了解决信息能独立于进程之外被长期存储，而引入了文件。 文件作为进程创建信息的逻辑单元，可被多个进程并发使用在Unix系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等I/O操作设计了一组通用的API，使他们被处理时均可统一使用字节流。 Lniux系统中除进程外的一切都是文件，为了便于文件管理而引入目录，这使Linux文件系统形成了一个层级结构的目录树。 Linux系统顶层目录结构 / 根目录├── bin 存放用户二进制文件├── boot 存放内核引导配置文件├── dev 存放设备文件├── etc 存放系统配置文件├── home 用户主目录├── lib 动态共享库├── lost+found 文件系统恢复时的恢复文件├── media 可卸载存储介质挂载点├── mnt 文件系统临时挂载点├── opt 附加的应用程序包├── proc 系统内存的映射目录，提供内核与进程信息├── root root 用户主目录├── sbin 存放系统二进制文件├── srv 存放服务相关数据├── sys sys 虚拟文件系统挂载点├── tmp 存放临时文件├── usr 存放用户应用程序└── var 存放邮件、系统日志等变化文件 Linux系统并不区分文件和目录，目录是记录其他文件名的文件 Linux将设备当做文件处理 打开并读取设备文件1234567int fd; struct input_event ie; fd = open(\"/dev/input/event3\", O_RDONLY); read(fd, &amp;ie, sizeof(struct input_event)); printf(\"type = %d code = %d value = %d\\n\", ie.type, ie.code, ie.value); close(fd); 其展示了如何打开设备文件event3并读取文件内容，文件event3表示一直输入设备，其可能是鼠标或键盘，通过查看 /proc/bus/input/devices 可知 event3 对应设备的类型。设备文件 /dev/input/event3 使用 read() 以字符流的方式被读取。结构体 input_event 被定义在内核头文件 linux/input.h 中。 文件都有文件名和数据，在Linux上被分成两部分：用户数据与元数据 用户数据：文件数据块（data block)，数据块是记录文件内容的地方 元数据：文件的附加属性，即文件大小、创建时间及所有者等信息。 在Linux中，元数据中的inode号为索引节点号，是文件的唯一标识。而文件名是为了方便人们记忆和使用，系统或程序是通过inode号来寻找正确的文件数据块。 查看inode号使用stat或ls -i命令 硬链接&amp;软链接链接不仅解决了Linux系统文件的共享使用，而且带来了隐藏文件路径、增加权限安全及节省存储等好处。 硬链接：一个inode号对应多个文件名文件A是文件B的硬链接，则A的目录项中的索引inode节点号与B的目录项中的inode节点相同，即同一个inode节点对应不同的文件名，两个文件名指向同一文件，A和B对于文件系统来说是完全等同的。 特点 文件有相同的 inode 及 data block只能对已存在的文件进行创建不能交叉文件系统进行硬链接的创建不能对目录进行创建，只可对文件创建删除一个硬链接文件并不影响其他有相同 inode 号的文件 123456789$ touch test$ echo \"This is a test.\" &gt; test$ cat test This is a test.$ ln test filetxt$ ls -litotal 8809185 -rw-rw-r-- 2 wonderxiao wonderxiao 16 10月 13 20:42 filetxt809185 -rw-rw-r-- 2 wonderxiao wonderxiao 16 10月 13 20:42 test 其中，809185是文件的inode值，你可简单将文件看作C语言的指针，它指向物理硬盘的一个区块。事实上，文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。 inode 是随着文件的存在而存在，因此只有当文件存在时才可创建硬链接，即当 inode 存在且链接计数器不为 0 时。 若修改刚才创建的filetxt文件： 1234$ echo \"New one\" &gt;&gt; filetxt $ cat test This is a test.New one 可看到，这两个就如同一个文件一样，inode值一样，都指向同一个区块。软链接——符号链接文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块,因此软链接的创建与使用没有类似硬链接的诸多限制。 特点 软链接有自己的文件属性及权限等可对不存在的文件或目录创建软链接软链接可交叉文件系统软链接可对文件或目录创建创建软链接时，链接计数 i_nlink 不会增加删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接 链接的访问123456$ ln -s filetxt softtxt$ ls -litotal 8809185 -rw-rw-r-- 2 wonderxiao wonderxiao 24 10月 13 21:11 filetxt809068 lrwxrwxrwx 1 wonderxiao wonderxiao 7 10月 13 21:14 softtxt -&gt; filetxt809185 -rw-rw-r-- 2 wonderxiao wonderxiao 24 10月 13 21:11 test 这个软链接的inode值不一样了，且文件属性为1，说明刚才创建的软链接文件根本不是同一类型。 若删除filetxt文件，然后输出软硬链接文件内容：1234$ rm filetxt$ cat testThis is a test.New one 12$ cat softtxtcat: softtxt: No such file or directory 之前硬链接没有任何影响，这是由于其inode所指向的区块有一个硬链接在指向它，所以此区块仍然有效，可继续访问。而软链接的inode所指向的内容实际上保存的是一个绝对路径，当用户访问这个文件时，即访问的是这个文件路径所在的文件。此时，这个文件已被删除，所以找不到它。 软链接：保存其代表的绝对路径，是另外一个文件，在硬盘上有独立的块，访问时会替换自身路径。 硬链接：代表的是文件的副本Linux VFSLinux有极其丰富的文件系统，可分为： 网络文件系统，如nfs、cifs等 磁盘文件系统，如ext4、ext3等 特殊文件系统，如proc、sysfs、ramfs、tmpfs等 这些文件系统系统在Linux下共存的基础是Linux VFS(Virtual File System)，VFS作为一个通用的文件系统，抽象定义了文件系统的四个基本概念： 文件 目录项 索引节点 挂载点 其在内核中，为用户空间层的文件系统提供了相关接口，即VFS实现了open()、read()等系统调用的函数，这就真正实现：在Linux系统中，除进程外一切都是文件。 VFS在系统中架构 VFS存在四个基本对象： 超级块对象(superblock object)一个已安装的文件系统 索引节点对象(inode object)一个文件 目录项对象(dentry object)一个目录项，如设备文件event3在路径/dev/input/event3中，存在四个目录项对象：/、dev/、input/及event3。 文件对象(file object)代表进程打开的文件 这四个对象与进程及磁盘文件间的关系如下图： 其中，d_inode为硬链接，是文件路径的快速解析。同时，Linux VFS设计了目录项缓存dcache。 在Linux中，索引节点结构存在于系统内存及磁盘中，其可分为VFS inode与实际文件系统的inode。VFS inode是作为实际文件系统中inode的抽象。 VFS中inode与inode_operations结构体12345678910111213141516171819struct inode &#123; ... const struct inode_operations *i_op; // 索引节点操作 unsigned long i_ino; // 索引节点号 atomic_t i_count; // 引用计数器 unsigned int i_nlink; // 硬链接数目 ... &#125; struct inode_operations &#123; ... int (*create) (struct inode *,struct dentry *,int, struct nameidata *); int (*link) (struct dentry *,struct inode *,struct dentry *); int (*unlink) (struct inode *,struct dentry *); int (*symlink) (struct inode *,struct dentry *,const char *); int (*mkdir) (struct inode *,struct dentry *,int); int (*rmdir) (struct inode *,struct dentry *); ... &#125; 每个文件存在两个计数器： i_count:引用计数,用于跟踪文件被访问的数量,或者说 i_count 跟踪文件在内存中的情况 i_nlink:硬链接计数,使用 ls -l 等命令查看到的文件硬链接数,即是磁盘计数器。当文件被删除时，则 i_nlink 先被设置成 0。 文件的这两个计数器使得 Linux 系统升级或程序更新变的容易。系统或程序可在不关闭的情况下（即文件 i_count 不为 0），将新文件以同样的文件名进行替换，新文件有自己的 inode 及 data block，旧文件会在相关进程关闭后被完整的删除。 文件系统 ext4 中的 inode12345678910struct ext4_inode &#123; ... __le32 i_atime; // 文件内容最后一次访问时间 __le32 i_ctime; // inode 修改时间 __le32 i_mtime; // 文件内容最后一次修改时间 __le16 i_links_count; // 硬链接计数 __le32 i_blocks_lo; // Block 计数 __le32 i_block[EXT4_N_BLOCKS]; // 指向具体的 block ... &#125;; 其中三个时间的定义可对应与命令 stat 中查看到三个时间。i_links_count 不仅用于文件的硬链接计数，也用于目录的子目录数跟踪（目录并不显示硬链接数，命令 ls -ld 查看到的是子目录数）。由于文件系统 ext3 对 i_links_count 有限制，其最大数为：32000（该限制在 ext4 中被取消）。 总结本文描述了 Linux 系统中文件与目录被引入的原因及 Linux 处理文件的方式，然后我们通过区分硬链接与软链接的不同，了解 Linux 中的索引节点的相关知识，并以此引出了 inode 的结构体。索引节点结构体存在在于 Linux VFS 以及实际文件系统中，VFS 作为通用文件模型是 Linux 中“一切皆是文件”实现的基础。文章并未深入 Linux VFS，也没涉及实际文件系统的实现，文章只是从 inode 了解 Linux 的文件系统的相关内容。","categories":[{"name":"linux","slug":"linux","permalink":"https://wonderxiao.github.io/categories/linux/"}],"tags":[{"name":"Linux内核","slug":"Linux内核","permalink":"https://wonderxiao.github.io/tags/Linux内核/"},{"name":"进程","slug":"进程","permalink":"https://wonderxiao.github.io/tags/进程/"},{"name":"操作系统","slug":"操作系统","permalink":"https://wonderxiao.github.io/tags/操作系统/"}]},{"title":"bit、Byte、bps、Bps、pps、Gbps的单位详细说明及换算","slug":"单位转换","date":"2017-06-22T16:25:36.000Z","updated":"2018-05-04T13:52:46.297Z","comments":true,"path":"2017/06/23/单位转换/","link":"","permalink":"https://wonderxiao.github.io/2017/06/23/单位转换/","excerpt":"","text":"bit 电脑记忆体中最小的单位，在二进位电脑系统中，每一bit 可以代表0 或 1 的数位信号。 Byte 字节单位，一般表示存储介质大小的单位，一个B（常用大写的B来表示Byte）可代表一个字元(A~Z)、数字(0~9)、符号(,.?!%&amp;+-*/)，但中文字需要2个Byte。1 Byte = 8 bits1 KB = 1024 Bytes1 MB = 1024 KB1 GB = 1024 MB 注意：在计算存储介质大小时，需要用2的n次方来换算（1KB = 2^10 Bytes）。 bps “bits per second”常用于表示数据机及网络通讯的传输速率。 例如GigabitEthernet端口：5 minute input rate 38410000 bits/sec6344 packets/sec382410000 bits/sec = 382.41Mbps所以常说的快速以太网能达到百兆传输，其实实际传输文件大小只有10MB = 100Mb 注意：在计算传输速率时，直接用1000来换算（1 Mb = 1000 Kb = 1000,000 bit）。 Bps “Byte per second”电脑一般都以Bps显示速度，但有时会跟传输速率混淆，例如ADSL宣称的带宽为1Mbps ，但在实际应用中，下载速度没有1MB ，只有1Mbps/8 = 128kBps。也就是说与传输速度有关的b一般指的是bit，与容量有关的B一般指的是Byte。 pps - 包转发率 包转发率标志了交换机转发数据包能力的大小。单位一般位pps（包每秒），一般交换机的包转发率在几十Kpps到几百Mpps不等。包转发速率是指交换机每秒可以转发多少百万个数据包（Mpps），即交换机能同时转发的数据包的数量。 包转发率以数据包为单位体现了交换机的交换能力。 Gbps - 背板带宽 交换机的背板带宽，是交换机接口处理器或接口卡和数据总线间所能吞吐的最大数据量。背板带宽标志了交换机总的数据交换能力，单位为Gbps，也叫交换带宽，一般的交换机的背板带宽从几Gbps到上百Gbps不等。一台交换机的背板带宽越高，所能处理数据的能力就越强，但同时设计成本也会越高。 从以下两个方面可以判断一台交换机背板带宽的可用性： ==所有端口容量×端口数量×2==小于等于背板带宽，可实现全双工无阻塞交换，证明交换机具有发挥最大数据交换性能的条件。 满配置吞吐量(Mpps) = 满配置GE端口数×1.488Mpps，其中1个千兆端口在包长为64字节时的理论吞吐量为1.488Mpps。 GE端口理论吞吐量-1.488Mpps 以太网传输最小包长是64字节。包转发线速的衡量标准是以单位时间内发送64byte的数据包（最小包）的个数作为计算基准的。 对于千兆以太网来说，计算方法如下：1000Mbps/((64B+8B+12B)×8bit)=1.488095pps 说明：当以太网帧为64Byte时，需考虑8Byte的前导符和12Byte的帧间隙的固定开销。 在以太网中，每个帧头都要加上了8个字节的前导符，前导符的作用在于告诉监听设备数据将要到来。然后，以太网中的每个帧之间都要有帧间隙，即每发完一个帧，之后要等待一段时间再发另外一个帧，在以太网标准中规定最小是12个字节，然而帧间隙在实际应用中有可能会比12个字节要大，在这里我用了最小值。每个帧都要有20个字节的固定开销。（另外这20字节的信息是不能通过抓包软件抓下来的） 因此一个全双工线速的千兆以太网端口在转发64Byte包时的包转发率为1.488Mpps。 以下是常用以太网端口的包转发率： 万兆以太网：14.88Mpps 千兆以太网：1.488Mpps 百兆以太网：0.1488Mpps Router 的 kbits 单位等同于 kbps 位 “位(bit)”是电子计算机中最小的数据单位。每一位的状态只能是0或1。 字节 8个二进制位构成1个”字节(Byte)”，它是存储空间的基本计量单位。 1个字节可以储存1个英文字母或者半个汉字，换句话说，1个汉字占据2个字节的存储空间。 KB 在一般的计量单位中，通常K表示1000。 例如：1公里= 1000米，经常被写为1km；1公斤=1000克，写为1kg。同样K在二进制中也有类似的含义。只是这时K表示1024，也就是2的10次方。1KB 表示1K个Byte，也就是1024个字节。MB：计量单位中的M(兆)是10的6次方，见到M自然想起要在该数值的后边续上六个0，即扩大一百万倍。在二进制中，MB也表示到了百万级的数量级，但1MB不正好等于1000000字节，而是1048576字节，即 1MB = 2$ e^{20} $Bytes = 1048576Bytes。 在标准10进制公制度量系统中，倍率关系如下所示 kilo (k)* = $ 10 ^ 3 $ = 1,000 thousand 千mega (M) = $ 10 ^ 6 $ = 1,000,000 million 百万giga (G) = $ 10 ^ 9 $ = 1,000,000,000 billion 十亿tera (T) = $ 10 ^ {12} $ = 1,000,000,000,000 trillion 万亿 ==在公制系统中， “k” 或者”kilo” 前缀只使用小写字母== 在计算机/通讯行业中，计算数据传送速度也使用每秒传送公制数据量来计算 1 bit (b) = 0 or 1 = one binary digit 一个二进制位元1 kilobit(kb)=$ 10 ^ 3 $ bits = 1,000 bits 一千位元1 Megabit(Mb)=$ 10 ^ 6 $ bits = 1,000,000 bits 一百万位元1 Gigabit(Gb)=$ 10 ^ 9 $ bits = 1,000,000,000 bits 一万亿位元 根据进制规定，传送速度可以有两种表示方法 bps 和 Bps,但是他们是有严格区别。Bps中的 B 使用的是二进制系统中的Byte字节 ,bps中的 b 是十进制系统中的位元。 在我们常说的56K拨号，100M局域网都是bps计量，当用于软件下载时，下载工具一般又以Bps计算，所以它们之间有 8 bit=1 Byte 的换算关系，那么56Kbps拨号极限下载速度是 56Kbps/8=7KBps 每秒下载7K字节 。 在数据存储，容量计算中，一般又结合公制的进制和二进制的数据计算方法来计算（二进制） 1 byte (B) = 8 bits (b) 字节=8个二进制位1 Kilobyte(K/KB)=$ 2^{10} $ bytes=1,024 bytes 千字节1 Megabyte(M/MB)=$ 2^{20} $ bytes=1,048,576 bytes 兆字节1 Gigabyte(G/GB)=$ 2^{30} $ bytes=1,073,741,824 bytes 千兆字节1 Terabyte(T/TB)=$ 2^{40} $ bytes=1,099,511,627,776 bytes吉字节 一些存储器厂家特别是硬盘厂家就更紧密结合十进制来计算，这就是为什么操作系统显示的容量与厂家标示的容量有些一些差异的原因（十进制） 1 byte (B) = 8 bits (b)1 Kilobyte (K / KB) = $ 10 ^ 3 $ bytes = 1,000 bytes1 Megabyte (M / MB) = $ 10 ^ 6 $ bytes = 1,000,000 bytes1 Gigabyte (G / GB) = $ 10 ^ 9 $ bytes = 1,000,000,000 bytes1 Terabyte (T / TB) = $ 10 ^ {12} $ bytes = 1,000,000,000,000 bytes 1． 计算机最小存储计量单位是：BIT（位） 2． 计算机最基本存储计量单位是：Bytes(字节) 3． Bit和Bytes的关系：8Bit=1Bytes 4． 其他常用单位：1KB（1千字节）、1Mb(1兆字节)、1GB（1千兆字节）、1TB（1千G） 5． 常用单位之间以210 为进制单位即1024为进制。 6． 常用单位之间的换算： 1K=512个汉字（手机） 1K=1Kb=1024b=8*1024 Bit 1M=1Mb=1024K=1024Kb=1024*1024B 1G=1Gb=1024M=1024Mb=1024*1024KB=10243B 1TB=1024GB=10242MB=10243KB=10244B=8*10244位 7． 英文母及符号占用字节 (1).在半角状态下1个英文字母或标点符号只占1个字节 (2).在全角状态下1个英文字母或标点符号只占2个字节 8． 汉字无论在半角还是全角状态下均占2个字节 参考资料：http://chongchong.blog.edu.cn/user1/6206/archives/2005/162431.shtml","categories":[{"name":"单位","slug":"单位","permalink":"https://wonderxiao.github.io/categories/单位/"}],"tags":[{"name":"单位转换","slug":"单位转换","permalink":"https://wonderxiao.github.io/tags/单位转换/"}]},{"title":"IPTV承载网络要求","slug":"IPTV承载网络要求","date":"2017-06-21T16:25:36.000Z","updated":"2018-05-04T13:54:49.015Z","comments":true,"path":"2017/06/22/IPTV承载网络要求/","link":"","permalink":"https://wonderxiao.github.io/2017/06/22/IPTV承载网络要求/","excerpt":"","text":"IPTV承载网： 接入网 汇聚网 CDN网 IPTV业务： 直播电视 视频点播 时移电视 ==这些数据流传输过程，对带宽要求、对时延要求、对并发量都都一定的要求。== IPTV 系统架构主要包括流媒体服务、节目采编、存储及认证计费等子系统，主要存储及传送内容是以MPEG-4为编码核心的流媒体文件。它是一个基于IP网络传输的系统，通常会在边缘设置内容分配服务节点，配置流媒体服务及存储设备。用户终端：IP机顶盒+电视机、PC机 IPTV基于IP组播（多播）协议，实现1对组的下发方式，同时支持VOD点播，要求整网设备支持组播协议，包括IGMP、PIM等。 目前国内IPTV均采用==专网==形式，==不与宽带接入服务共享带宽，同时也不提供互联网接入服务。== OTT特点 使用大量高新技术、视频编码技术、云技术、切片存储网络开放，可访问互联网上业务。 IPTV业务属于高带宽业务，要求端到端网络具有大容量的承载能力。另外，高清、VOD业务量也在增加，对网络提出了更高的要求。 运营商在建网之前需要充分评估网络的视频承载能力、业务与网络承载能力的增速是否匹配、网络能支撑多少用户、网络是否会阻碍业务的发展等。 设备评估主要评估网络设备对IPTV业务的承载能力， 涉及三层网络设备、 二层网络设备、 家庭组网设备的承载能力评估。 IPTV业务承载网包括接入网、城域汇聚网、IPTV网关和骨干网几部分组成；IPTV平台按三级结构部署，中心节点负责接收片源视频流并进行存储、编解码；中心节点到区域中心一般采用单播形式把视频流引下来。 网络提供服务： 互联网、电视、视频点播、VoIP（IP语音）、数据存储、监控服务、电子邮件、备份、安全等 视频业务：IPTV、手机TV、互联网OTT TV、4K、多屏互动","categories":[{"name":"视频","slug":"视频","permalink":"https://wonderxiao.github.io/categories/视频/"}],"tags":[{"name":"IPTV","slug":"IPTV","permalink":"https://wonderxiao.github.io/tags/IPTV/"}]}]}