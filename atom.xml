<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>思想直播信号</title>
  
  <subtitle>醉心天地，码代云轻</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wonderxiao.github.io/"/>
  <updated>2018-05-09T12:53:29.392Z</updated>
  <id>https://wonderxiao.github.io/</id>
  
  <author>
    <name>wonderxiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wget命令</title>
    <link href="https://wonderxiao.github.io/2018/05/10/wget%E5%91%BD%E4%BB%A4/"/>
    <id>https://wonderxiao.github.io/2018/05/10/wget命令/</id>
    <published>2018-05-09T18:57:19.000Z</published>
    <updated>2018-05-09T12:53:29.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><ul><li>用来从指定的URL下载文件</li></ul><p>wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性。如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget (选项) (参数)</div></pre></td></tr></table></figure><blockquote><p><strong>选项</strong><br>-a&lt;日志文件&gt;：在指定的日志文件中记录资料的执行过程；<br>-A&lt;后缀名&gt;：指定要下载文件的后缀名，多个后缀名之间使用逗号进行分隔；<br>-b：进行后台的方式运行wget；<br>-B&lt;连接地址&gt;：设置参考的连接地址的基地地址；<br>-c：继续执行上次终端的任务；<br>-C&lt;标志&gt;：设置服务器数据块功能标志on为激活，off为关闭，默认值为on；<br>-d：调试模式运行指令；<br>-D&lt;域名列表&gt;：设置顺着的域名列表，域名之间用“，”分隔；<br>-e&lt;指令&gt;：作为文件“.wgetrc”中的一部分执行指定的指令；<br>-h：显示指令帮助信息；<br>-i&lt;文件&gt;：从指定文件获取要下载的URL地址；<br>-l&lt;目录列表&gt;：设置顺着的目录列表，多个目录用“，”分隔；<br>-L：仅顺着关联的连接；<br>-r：递归下载方式；<br>-nc：文件存在时，下载文件不覆盖原有文件；<br>-nv：下载时只显示更新和出错信息，不显示指令的详细执行过程；<br>-q：不显示指令执行过程；<br>-nh：不查询主机名称；<br>-v：显示详细执行过程；<br>-V：显示版本信息；<br>–passive-ftp：使用被动模式PASV连接FTP服务器；<br>–follow-ftp：从HTML文件中下载FTP连接文件。  </p><p><strong>参数</strong><br>URL：下载指定的URL地址</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>使用wget下载单个文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget https://www.wonderxiao.cn/test.zip</div></pre></td></tr></table></figure><p>表示从网络下载一个文件并保存在当前目录，在下载过程中会显示进度条，包含下载完成百分比、已下载字节、当前下载速度和剩余下载时间。</p><ul><li>下载并以不同的文件名保存</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -O test.zip https://www.wonderxiao.cn/download.aspx?id=1000</div></pre></td></tr></table></figure><p>wget会默认以最后一个符合/的后面的字符来命名，对于动态链接的下载，通常文件名会不正确。</p><ul><li>wget限速下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget --<span class="built_in">limit</span>-rate=300k https://www.wonderxiao.cn/test.zip</div></pre></td></tr></table></figure><p>当执行wget后，它会默认占用全部可能的带宽下载。但当你准备下载一个大文件时，而你仍需下载其他文件就需要进行限速处理。</p><ul><li>wget断点续传</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -c https://www.wonderxiao.cn/test.zip</div></pre></td></tr></table></figure><p>使用wget -c重新启动下载中断的文件。对于当我们下载大文件时突然由于网络等原因中断特别有帮助，使用该命令可继续接着下载而不是重新下载一个文件。</p><ul><li>wget后台下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ wget -b https://www.wonderxiao.cn/test.zip</div><div class="line">Continuing <span class="keyword">in</span> background, pid 1840.</div><div class="line">Output will be written to `wget-log<span class="string">'.</span></div></pre></td></tr></table></figure><p>对于下载非常大的文件的时候，可以通过使用参数-b进行后台下载。同时，可使用一下命令察看下载进度：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tail -f wget-log</div></pre></td></tr></table></figure><ul><li>伪装代理名称下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget wget --user-agent=<span class="string">"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16"</span> https://www.wonderxiao.cn/test.zip</div></pre></td></tr></table></figure><p>有些网站能通过根据代理名称而不是浏览器而拒绝你的下载请求，不过你可以设置–user-agent参数来进行伪装。</p><ul><li>测试下载链接</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget --spider URL</div></pre></td></tr></table></figure><p>有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent参数伪装。</p><p>如果下载链接正确，将会显示:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Spider mode enabled. Check <span class="keyword">if</span> remote file exists.</div><div class="line">HTTP request sent, awaiting response... 200 OK</div><div class="line">Length: unspecified [text/html]</div><div class="line">Remote file exists and could contain further links,</div><div class="line">but recursion is disabled -- not retrieving.</div></pre></td></tr></table></figure></p><p>这保证下载能在预定的时间内进行，但当你给错了一个链接时，将显示如下错误：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ wget --spider url</div><div class="line">Spider mode enabled. Check <span class="keyword">if</span> remote file exists.</div><div class="line">HTTP request sent, awaiting response... 404 Not Found</div><div class="line">Remote file does not exist -- broken link!!!</div></pre></td></tr></table></figure></p><p>你可以在以下几种情况下使用–spider参数：</p><ol><li>定时下载之前进行检查</li><li>间隔检测网站是否可用</li><li>检查网站页面的死链接</li></ol><ul><li>增加重试次数<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget --tries=40 URL</div></pre></td></tr></table></figure></li></ul><p>如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用–tries增加重试次数。</p><ul><li>下载多个文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -i filelist.txt</div></pre></td></tr></table></figure><p>首先，保存一份下载链接文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cat filelist.txt</div><div class="line">url1</div><div class="line">url2</div><div class="line">url3</div></pre></td></tr></table></figure></p><p>接着，使用这个文件和参数-i进行下载。</p><ul><li>镜像网站<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget --mirror -p --convert-links -P ./LOCAL URL</div></pre></td></tr></table></figure></li></ul><p>下载整个网站到本地</p><blockquote><p> –mirror 表示镜像下载<br>   -p 下载所有以HTML页面显示正常的文件<br>   –convert-links 下载后，转换成本地链接<br>   -P ./LOCAL  保存所有文件和目录到本地指定目录  </p></blockquote><ul><li>过滤指定格式下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget --reject=gif ur</div></pre></td></tr></table></figure><p>下载一个网站，但你不希望下载图片，可以使用这条命令。</p><ul><li>把下载信息存入日志文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -o download.log URL</div></pre></td></tr></table></figure><p>不希望下载信息直接显示在终端而是在一个日志文件，可以使用。</p><ul><li>限制总下载文件大小</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -Q5m -i filelist.txt</div></pre></td></tr></table></figure><p>当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</p><ul><li>下载指定格式文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -r -A.pdf url</div></pre></td></tr></table></figure><p>可以在以下情况使用该功能：  </p><ol><li>下载一个网站的所有图片  </li><li>下载一个网站的所有视频  </li><li>下载一个网站的所有PDF文件  </li></ol><ul><li>FTP下载</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ wget ftp-url</div><div class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</div></pre></td></tr></table></figure><p>可以使用wget来完成ftp链接的下载。</p><ul><li>使用wget匿名ftp下载：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget ftp-url</div></pre></td></tr></table></figure><ul><li>使用wget用户名和密码认证的ftp下载：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget --ftp-user=USERNAME --ftp-password=PASSWORD url</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用wget命令可以很方面的对远程文件进行下载及网站链接的有效性进行检测。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;wget命令&quot;&gt;&lt;a href=&quot;#wget命令&quot; class=&quot;headerlink&quot; title=&quot;wget命令&quot;&gt;&lt;/a&gt;wget命令&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;用来从指定的URL下载文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;wget非常稳定，它在带宽很窄的情况下和
      
    
    </summary>
    
      <category term="linux" scheme="https://wonderxiao.github.io/categories/linux/"/>
    
    
      <category term="linux命令" scheme="https://wonderxiao.github.io/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>tinyhttpd源码分析（一）</title>
    <link href="https://wonderxiao.github.io/2018/05/07/tinyhttpd%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wonderxiao.github.io/2018/05/07/tinyhttpd源码分析（一）/</id>
    <published>2018-05-06T16:34:32.000Z</published>
    <updated>2018-05-07T01:18:09.169Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>tinyhttpd是由J.David Blackstone在1999年写的不到500行的轻量级HTTP Server,通过学习源码，可以帮助我们真正理解服务器程序的本质。</p><h3 id="2-源码链接"><a href="#2-源码链接" class="headerlink" title="2. 源码链接"></a>2. 源码链接</h3><p>链接：<a href="http://tinyhttpd.sourceforge.net" target="_blank" rel="external">http://tinyhttpd.sourceforge.net</a></p><h3 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3. 准备工作"></a>3. 准备工作</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-介绍&quot;&gt;&lt;a href=&quot;#1-介绍&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍&quot;&gt;&lt;/a&gt;1. 介绍&lt;/h3&gt;&lt;p&gt;tinyhttpd是由J.David Blackstone在1999年写的不到500行的轻量级HTTP Server,通
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GDB调试工具</title>
    <link href="https://wonderxiao.github.io/2018/05/05/GDB%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/"/>
    <id>https://wonderxiao.github.io/2018/05/05/GDB调试工具/</id>
    <published>2018-05-05T10:02:59.000Z</published>
    <updated>2018-05-08T02:14:43.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>GDB是GNU开源组织发布的、在UNIX/Linux操作系统下，基于命令行的调试工具。</p><h3 id="1-启动gdb"><a href="#1-启动gdb" class="headerlink" title="1. 启动gdb"></a>1. 启动gdb</h3><ul><li><p>对于C/C++程序的调试，需在编译前添加-g选项：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ g++ -g hello.cpp -o hello</div></pre></td></tr></table></figure></li><li><p>调试可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gdb &lt;program&gt;</div></pre></td></tr></table></figure></li></ul><p>program为可执行文件，一般在当前目录下。</p><ul><li><p>调试core文件(core是程序非法执行错误后，core dump产生的文件)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gdb &lt;program&gt; &lt;core dump file&gt;</div><div class="line">$ gdb program core.11127</div></pre></td></tr></table></figure></li><li><p>调试服务程序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ gdb &lt;program&gt; &lt;PID&gt;</div><div class="line">$ gdb hello 11127</div></pre></td></tr></table></figure></li></ul><p>若程序为一个服务程序，那么可指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试它，program应该在PATH环境变量中搜索得到。</p><h3 id="2-gdb交互命令"><a href="#2-gdb交互命令" class="headerlink" title="2. gdb交互命令"></a>2. gdb交互命令</h3><p>启动gdb后，进入交互模式，通过以下命令完成对程序的调试。其中，有些命令可进行缩写。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a><strong>运行</strong></h3><ul><li>run : 简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令</li><li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li><li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内</li><li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li><li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体</li><li>until+行号： 运行至某行，不仅仅用来跳出循</li><li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息</li><li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li><li>quit：简记为 q ，退出gdb</li></ul><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a><strong>设置断点</strong></h3><ul><li>break n （简写b n）:在第n行处设置断点（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</li><li>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</li><li>delete 断点号n：删除第n个断点</li><li>disable 断点号n：暂停第n个断点</li><li>enable 断点号n：开启第n个断点</li><li>clear 行号n：清除第n行的断点</li><li>info b （info breakpoints） ：显示当前程序的断点设置情况</li><li>delete breakpoints：清除所有断点</li></ul><h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a><strong>查看源代码</strong></h3><ul><li>list : 简记为 l ，其作用就是列出程序的源代码，默认每次显示10行</li><li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li><li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li><li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容</li></ul><h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a><strong>打印表达式</strong></h3><ul><li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li><li>print a：将显示整数 a 的值</li><li>print ++a：将把 a 中的值加1,并显示出来</li><li>print name：将显示字符串 name 的值</li><li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li><li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li><li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li><li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li><li>whatis ：查询变量或函数</li><li>info function： 查询函数</li><li>扩展info locals： 显示当前堆栈页的所有变量</li></ul><h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a><strong>查询运行信息</strong></h3><ul><li>where/bt : 当前运行的堆栈列表</li><li>bt backtrace : 显示当前调用堆栈</li><li>up/down : 改变堆栈显示的深度</li><li>set args : 指定运行时的参数</li><li>show args : 查看设置好的参数</li><li>info program : 查看程序是否在运行及进程号和被暂停的原因</li></ul><h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a><strong>分割窗口</strong></h3><ul><li>layout : 分割窗口，可以一边看代码，一边调试</li><li>layout src : 显示源代码窗口</li><li>layout asm : 显示反汇编窗口</li><li>layout regs : 显示源代码/反汇编和CPU寄存器窗口</li><li>layout split : 显示源代码和反汇编窗口</li><li>Ctrl + L : 刷新窗口</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;GDB是GNU开源组织发布的、在UNIX/Linux操作系统下，基于命令行的调试工具。&lt;/p&gt;
&lt;h3 id=&quot;1-启动gdb&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="linux" scheme="https://wonderxiao.github.io/categories/linux/"/>
    
    
      <category term="gdb调试" scheme="https://wonderxiao.github.io/tags/gdb%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>位图学习</title>
    <link href="https://wonderxiao.github.io/2018/03/29/%E4%BD%8D%E5%9B%BE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wonderxiao.github.io/2018/03/29/位图学习/</id>
    <published>2018-03-29T09:08:46.000Z</published>
    <updated>2018-05-08T02:10:21.717Z</updated>
    
    <content type="html"><![CDATA[<p>已知a.txt中有40亿个无符号整数，b.txt中有10000个无符号整数，求交集。可用内存：1G</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>位图法是bitmap的缩写，其指用每一位来存放某种状态，适用于大规模数据，但数据状态不多的情况<br>举例说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> bit[N];</div></pre></td></tr></table></figure><p>在该数组成可存储N*sizeof(int)<em>8个数据，但最大的数只能是N</em>sizeof(int)*8-1。若存数据范围0~15，则使N=1即可<br><img src="https://upload-images.jianshu.io/upload_images/11305942-53474496b8230b37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="位图举例"><br>数据为【5，12，1，0，4】存入后：<br><img src="https://upload-images.jianshu.io/upload_images/11305942-604fbc46d3d42a35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="位图举例2"></p><h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><p>使用bit数组来表示某些元素是否存在，如8位电话号码等</p><h2 id="位图的操作"><a href="#位图的操作" class="headerlink" title="位图的操作"></a>位图的操作</h2><p>在C++中int类型由4个字节，即32位。当有1000万条不同数据时，我们只需1000万个位来表示，也就是10000000/(8*1024*1024)MB，约为1.25MB<br>1MB=1000KB=10^6B—–百万字节<br>1GB=1000MB=10^9B—–十亿字节<br>1000万条=10^7=(10/8)*10^6 B=1.25MB</p><p>使用一个unsigned int类型的数组或向量来表示位图，假定vector<unsigned int="">a，则第i为可表示为a[i/32]的i%32位（其中，32*N+r=i）</unsigned></p><blockquote><p>i/32使用位移操作：i&gt;&gt;5，i%32使用：i&amp;31</p></blockquote><ul><li><p>setZero置零操作<br>将位图中第i位置零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[i&gt;&gt;<span class="number">5</span>] &amp;= ~(<span class="number">1</span>&lt;&lt;(i&amp;<span class="number">31</span>));</div></pre></td></tr></table></figure></li><li><p>setOne置位操作<br>将位图中的第i位设置为1，即将a[i/32]的第（i%32）位设置为1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a[i&gt;&gt;<span class="number">5</span>] |= (<span class="number">1</span>&lt;&lt;(i&amp;<span class="number">31</span>));</div></pre></td></tr></table></figure></li><li><p>getState获取状态操作<br>判断第i位是否为1，得到的值大于0，说明该位值为1，否则为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> a[i&gt;&gt;<span class="number">5</span>] &amp;(<span class="number">1</span>&lt;&lt;(i&amp;<span class="number">31</span>));</div></pre></td></tr></table></figure></li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT_INT 32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1f</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4294967296</span></div><div class="line"></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> *a = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createALL</span><span class="params">()</span></span>&#123;</div><div class="line">a = <span class="keyword">new</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>[<span class="number">1</span>+N/BIT_INT];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteALL</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">delete</span>[] a;</div><div class="line">    a = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetAllZero</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,(<span class="number">1</span>+N/BIT_INT)*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setOne</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">a[i &gt;&gt; SHIFT] |= (<span class="number">1</span>&lt;&lt;(i&amp;MASK));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setZero</span><span class="params">()</span></span>&#123;</div><div class="line">a[i &gt;&gt; SHIFT] &amp;= ~(<span class="number">1</span>&lt;&lt;(i&amp;MASK));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">getState</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> i)</span></span>&#123;</div><div class="line"><span class="keyword">return</span> (a[i &gt;&gt; SHIFT] &amp;(<span class="number">1</span> &lt;&lt; (i&amp;MASK)));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setStateFromFile</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="function">ifstream <span class="title">cin</span><span class="params">(<span class="string">"a.txt"</span>)</span></span>;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> n;</div><div class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</div><div class="line">    setOne(n);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printCommonNumber</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="function">ifstream <span class="title">cin</span><span class="params">(<span class="string">"b.txt"</span>)</span></span>;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> n;</div><div class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="number">1</span> == getState(n))</div><div class="line">      <span class="built_in">cout</span>&lt;&lt;n&lt;&lt;<span class="string">" "</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  createALL();</div><div class="line">  SetAllZero();</div><div class="line">  setStateFromFile();</div><div class="line">  printCommonNumber();</div><div class="line">  deleteALL();</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="函数库实现"><a href="#函数库实现" class="headerlink" title="函数库实现"></a>函数库实现</h2><p>C++的STL中有bitmap类，它提供了很多方法，详见<a href="http://www.cplusplus.com/reference/stl/bitset/" target="_blank" rel="external">http://www.cplusplus.com/reference/stl/bitset/</a></p><ul><li>使用C++的bitset:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bitset&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></div><div class="line"><span class="built_in">bitset</span>&lt;N&gt; b;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">  <span class="keyword">int</span> n;</div><div class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)&#123;</div><div class="line">    b.<span class="built_in">set</span>(n);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i ++)&#123;</div><div class="line">    <span class="keyword">if</span>(b.test(i))&#123;</div><div class="line">      <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>注意：<br>bitset<n>不能放在main内，否则stack overflow。若要放在main内，要放在main内，要加static或new一个。</n></p></blockquote><h2 id="位图应用"><a href="#位图应用" class="headerlink" title="位图应用"></a>位图应用</h2><ul><li>求字符的所有组合</li></ul><blockquote><p>思路：输入a、b、c,则它们的组合为a,b,c,ab,ac,bc,abc。</p></blockquote><p>假设原有元素有n个，则最终组合为2^n-1个。利用位图思想，假设原有a、b、c三个元素，则1表示取元素，0表示不取。故取a则为001，取ab则为011，而000没有意义，所以共有2^n个结果。<br>这些位图值都是1,2,…,2^n,所以从值1到值2^n-1的输出结果为：<br>001,010,…,111<br>对应观察结果为：a,b,ab,c,ac,bc,abc。<br>因此，循环1~2^n-1，然后输出组合结果即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</div><div class="line"><span class="keyword">if</span> (str == <span class="string">" "</span>)</div><div class="line">&#123;</div><div class="line"><span class="keyword">return</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">int</span> len = str.length();</div><div class="line"><span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; len;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++ )</div><div class="line">&#123;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len;j ++)</div><div class="line">&#123;</div><div class="line"><span class="keyword">int</span> temp = i;</div><div class="line"><span class="keyword">if</span> (temp &amp;(<span class="number">1</span> &lt;&lt; j))</div><div class="line"><span class="built_in">cout</span> &lt;&lt; str[j];</div><div class="line">&#125;</div><div class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">string</span> str = <span class="string">"abc"</span>;</div><div class="line">combination(str);</div><div class="line">system(<span class="string">"pause"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>bitmap求哈密尔顿距离</li></ul><blockquote><p>问题描述<br>给定N（1&lt;=N&lt;=100000）个五维的点(X1,X2,X3,X4,X5)，求两点X(x1,x2,x3,x4,x5)和Y(y1,y2,y3,y4,y5)使得|x1-y1|+|x2-y2|+|x3-y3|+|x4-y4|+|x5-y5|最大</p></blockquote><ul><li>解题思路  </li></ul><p>对于任意两点(x1,x2)和(y1,y2)  </p><p>|x1-y1|=max(x1-y1,y1-x1);<br>=&gt;|x1-y1|+|x2-y2|=max{<br>  (x1-y1)+(x2-y2)<br>  (x1-y1)-(x2-y2)<br>  (y1-x1)+(x2-y2)<br>  (y1-x1)-(x2-y2)<br>};  </p><p>=max{<br>  (x1+x2)-(y1+y2)<br>  (x1-x2)-(y1-y2)<br>  (-x1+x2)-(-y1+y2)<br>  (-x1-x2)-(-y1-y2)<br>};  </p><p>通过观察，发现每一对相同元的符号必定相反，如：xi-yi，于是使用bitmap的思想来枚举这些二维的点的x轴和y轴前的正负号，这样可用一个0~3的二进制形式来表示：0表示+号，1表示-号。</p><p>对于每个点X和Y的符号，可用A[4]数组存储下来，那么对于点1(x1,y1)和2(x2,y2)两点就可表示为下式一：</p><blockquote><p>A[1][0] - A[2][0]<br>A[1][1] - A[2][1]<br>A[1][2] - A[2][2]<br>A[1][3] - A[2][3]</p></blockquote><p>约定X[ij]的下标数字(ij)是二进制，令  </p><p>X00=x1+x2<br>X01=x1-x2<br>X10=-x1+x2<br>X11=-x1-x2</p><p>假设有A-Z共26个点，则<br>result=max{<br>  (A00-B00), (A01-B01), (A10-B10), (A11-B11),<br>  (A00-C00), (A01-C01), (A10-C10), (A11-C11),<br>   ……<br>   (X00-Y00), (X01-Y01), (X10-Y10), (X11-Y11),<br>   (Y00-Z00), (Y01-Z01), (Y10-Z10), (Y11-Z11),<br>}  </p><p>很明显，对上面每一列应用max运算：  </p><blockquote><p>max(第一列)=<br>max(A00,B00,…,Z00) - min(A00,B00,…,Z00)  </p></blockquote><p>result=max{max(第一列)，max(第二列) … };  </p><p>对每个I(00,01,10,11)，求A[*][I]的最大值max(I)和最小值min(I),然后再求max{max(I)-min(I)}  </p><ul><li>通俗的理解</li></ul><blockquote><p>先求A[i][I]-A[j][I](I=00,01,10,11)，还原就是先求该等式xi+xj-(yi+yj)的最大值,分解后变成求max(xi+xj)和min(yi+yj)。再求这两个数相差后得到的集合中的最大值即可。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;已知a.txt中有40亿个无符号整数，b.txt中有10000个无符号整数，求交集。可用内存：1G&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;位图法是bitmap的缩写
      
    
    </summary>
    
      <category term="算法" scheme="https://wonderxiao.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="https://wonderxiao.github.io/tags/C/"/>
    
      <category term="大数据存储" scheme="https://wonderxiao.github.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
  </entry>
  
  <entry>
    <title>网络流量识别</title>
    <link href="https://wonderxiao.github.io/2018/03/28/%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E8%AF%86%E5%88%AB/"/>
    <id>https://wonderxiao.github.io/2018/03/28/网络流量识别/</id>
    <published>2018-03-28T10:08:52.000Z</published>
    <updated>2018-05-08T02:10:42.910Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/11305942-accd5ba9ef5d4894.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络流量识别"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/11305942-accd5ba9ef5d4894.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="科研" scheme="https://wonderxiao.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="流量识别" scheme="https://wonderxiao.github.io/tags/%E6%B5%81%E9%87%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>协议栈分析（一）</title>
    <link href="https://wonderxiao.github.io/2018/03/25/%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://wonderxiao.github.io/2018/03/25/协议栈分析（一）/</id>
    <published>2018-03-24T20:55:09.000Z</published>
    <updated>2018-05-08T02:14:58.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="协议栈在Linux中的位置"><a href="#协议栈在Linux中的位置" class="headerlink" title="协议栈在Linux中的位置"></a>协议栈在Linux中的位置</h2><p><img src="https://upload-images.jianshu.io/upload_images/11305942-f035c067a6cbd9c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP_STACK"></p><h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p><img src="https://upload-images.jianshu.io/upload_images/11305942-fa1bf798cea19287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI七层模型"></p><h2 id="IP作用"><a href="#IP作用" class="headerlink" title="IP作用"></a>IP作用</h2><p><img src="https://upload-images.jianshu.io/upload_images/11305942-d7a2eee6f25b4cfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="IP作用"></p><ul><li>IP是连接传输链路层和传输层额中枢，不仅为数据在系统上下方向上传输，也为机器间在水平方向上进行数据传输，将链路层简称为2层或L2，网络层为3层或L3，传输层为4层或L4</li><li>ETH代表以太网功能，是2层功能的具体实现</li><li>ARP是2层和3层之间的连接层，可认为是2.5层协议</li><li>L2协议包括PPP、SLIP及Ethernet，都为底层传输协议</li></ul><blockquote><p>每一类软件模块都不能独立存在，必须依托系统其他模块的支持才能正常工作。由于协议栈在内核中实现，所以必须弄清楚操作系统是如何支持协议栈的</p></blockquote><ul><li>下图为真实操作系统的协议栈实现<br><img src="https://upload-images.jianshu.io/upload_images/11305942-b8f534f08a32f833.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协议栈实现"><br>通过上图可以知道，在操作系统实现协议栈额过程中，有两个模块很重要——<strong>glibc库</strong>和<strong>INET模块</strong></li><li><p>glibc<br>提供了各种API接口供用户空间程序的系统调用，来告知内核态来进行资源调整、数据传输。不管应用层软件开发，还是嵌入式软件开发，我们使用的malloc函数、strcpy函数都是由该库提供的。同时，网络编程使用的API接口也是该库提供的。</p></li><li><p>INET<br>它不属于TCP/IP体系必须的一部分，但它提供了访问TCP/IP层的接口，这些接口是在网络初始化时就已注册到socket层，即是我们常说的socket、bind、connect、listen、send和recv等系统接口。这些接口内部不仅支持你上网（如AF_INET），还支持你的应用程序间的通信（如AF_UNIX）或内核与用户之间的通信（AF_NETLINK），甚至一些少见的协议（如AF_IPX），也就是说，通过这一层的实现，来封装我们经常使用的TCP/IP的接口。</p></li></ul><h2 id="系统初始化流程"><a href="#系统初始化流程" class="headerlink" title="系统初始化流程"></a>系统初始化流程</h2><blockquote><p>Linux系统的启动，指从系统加电后直至系统控制台显示“login:”登录提示符为止的系统运行阶段</p></blockquote><p>与该启动流程相关的代码有：<br>  ● 四个汇编程序：bootsect.S  setup.S head.S entry.S<br>  ● init目录下的main函数<br>流程如下图所示：<br><img src="https://upload-images.jianshu.io/upload_images/11305942-3d0116bd77ae70dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统初始化引导流程"></p><ul><li>与内核启动相关的函数<br><img src="https://upload-images.jianshu.io/upload_images/11305942-551a6597dcc7d813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内核启动函数"><br>需要关注以下几点：</li><li>中断系统及调度系统</li><li>文件系统初始化</li><li>设备管理系统的初始化</li><li>网络协议的初始化<br>由于网络系统本身关系到设备、文件系统及任务调度等方面，若这几方面的知识不整明白，那么对协议栈理解就很难了。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;协议栈在Linux中的位置&quot;&gt;&lt;a href=&quot;#协议栈在Linux中的位置&quot; class=&quot;headerlink&quot; title=&quot;协议栈在Linux中的位置&quot;&gt;&lt;/a&gt;协议栈在Linux中的位置&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://upload-i
      
    
    </summary>
    
      <category term="linux" scheme="https://wonderxiao.github.io/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://wonderxiao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>内存分配</title>
    <link href="https://wonderxiao.github.io/2018/03/25/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://wonderxiao.github.io/2018/03/25/内存分配/</id>
    <published>2018-03-24T20:41:56.000Z</published>
    <updated>2018-05-04T13:50:45.007Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><ul><li><p>从静态存储区域分配<br>内存在程序编译时就已分配好，这块内存在程序的整个运行期间都存在，<br>如：全局变量，static变量</p></li><li><p>在栈上创建<br>在执行函数时，函数内局部变量的存储单元都可在栈上创建，函数执行结束时这些存储单元自动释放<br>栈内存分配运算内置于处理器的指令集中，效率很高，但分配的内存容量有限</p></li><li><p>从堆上分配，亦称动态内存分配<br>程序在运行时，用malloc或new申请任意多少的内存，程序员自己负责在何时使用free或delete释放内存<br>动态内存的生存期由程序员决定，使用灵活</p></li></ul><h2 id="C语言中内存申请相关的函数"><a href="#C语言中内存申请相关的函数" class="headerlink" title="C语言中内存申请相关的函数"></a>C语言中内存申请相关的函数</h2><blockquote><p>alloca、calloc、malloc、free、realloc、sbrk</p></blockquote><ul><li>alloca是向栈申请内存，因此无需释放；malloc分配的内存位于堆中，且没初始化内存的内容。因此，在malloc之后，调用memset来初始化这部分的内存空间</li><li>calloc将初始化这部分的内对空间设置为0</li><li>realloc对malloc申请的内存进行大小的调整，申请的内存最终通过free来释放</li><li>sbrk增加数据段的大小</li><li>malloc、calloc和free都是C函数库实现的，与OS无关<br>C函数库内部通过一定的结构来保存当前有多少可用内存，若程序申请的malloc的大小超过库里所留的空间，则将先调用sbrk系统调用来增加可用空间，再进行分配空间</li></ul><p>free时，释放的内存并不立即返回给OS，而是保留在内部结构中。</p><blockquote><p>sbrk类似批发，一次性向OS申请大的内存，malloc等类似零售，满足程序运行时需求，这套机制类似缓冲。</p></blockquote><p>基于这套机制开发的原因：<br>  ● 系统调用不能支持任意大小的内存分配，有的系统调用只支持固定大小即其倍数的内存申请，这样会造成需使用小内存而申请大内存空间的浪费<br>  ● 系统调用申请内存代价大，涉及用户态到内核态的转换</p><h2 id="malloc和calloc分配动态内存空间"><a href="#malloc和calloc分配动态内存空间" class="headerlink" title="malloc和calloc分配动态内存空间"></a>malloc和calloc分配动态内存空间</h2><p><strong>区别</strong>：</p><ul><li><p>malloc( )函数有一个参数，即所分配内存空间的大小<br>void *malloc(size_t size);<br>calloc( )函数有两个参数，分别为元素数目和元素大小，参数乘积为要分配的内存空间大小<br>void *calloc(size_t numElements, size_t sizeOfElement);<br>若调用成功，函数malloc( )和calloc( )都将返回所分配的内存空间的首地址</p></li><li><p>malloc( )不能初始化所分配的内存空间，calloc( )可以<br>若malloc函数分配的内存空间之前没使用过，则每一位可能都是0；但这部分空间曾被分配、释放或重新分配，则可能存留各种各样的数据。换句话说，即使用malloc函数的程序开始时（内存空间没重新分配）能正常运行，但经过一段时间后（内存空间）可能出现问题<br>calloc函数会将所分配的内存空间中的每一位都初始化为0</p></li><li>malloc函数只返回一个对象，而calloc函数会返回一个由某种对象组成的数组。如为数组分配内存空间时，可选用calloc函数</li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>在calloc函数和malloc函数之间选择时，只需考虑是否初始化所分配的内存空间，而不要考虑函数是否能返回一个数组。因为，尽管malloc并不能返回一个数组，但它所分配的内存空间仍能供一个数组使用</li><li>当程序运行中有malloc时，但没有free，会造成内存泄露。由于一部分内存未被使用而又没被free，因此系统认为这部分内存仍在使用，造成不断的向系统申请内存，使系统可用内存不断减少。但是，内存泄露仅仅指程序在运行时，程序退出时，OS将回收所有资源</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存分配方式&quot;&gt;&lt;a href=&quot;#内存分配方式&quot; class=&quot;headerlink&quot; title=&quot;内存分配方式&quot;&gt;&lt;/a&gt;内存分配方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从静态存储区域分配&lt;br&gt;内存在程序编译时就已分配好，这块内存在程序的整个运行期间都存在，
      
    
    </summary>
    
      <category term="内存管理" scheme="https://wonderxiao.github.io/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="内存分配" scheme="https://wonderxiao.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>腾讯电话面试经</title>
    <link href="https://wonderxiao.github.io/2018/03/22/%E8%85%BE%E8%AE%AF%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    <id>https://wonderxiao.github.io/2018/03/22/腾讯电话面试经/</id>
    <published>2018-03-22T09:21:56.000Z</published>
    <updated>2018-05-08T02:10:53.759Z</updated>
    
    <content type="html"><![CDATA[<p>首先进行自我介绍！<br>因为刚开始通话时，我已做过自我介绍。所以，在进行自我介绍时，我介绍了一下我做的3个项目。<br>然后，面试官说对第一个项目比较感兴趣，我就开始介绍。介绍完之后，我说到了流量控制，然后面试官问到了netfilter的几个函数。<br>我简要的说有几个函数，然后问我几个函数之间的关系，没了解过，所以没答上来。</p><p><strong>之后的一些问题：</strong></p><ul><li>C++方面的知识：<br>第一个问题是虚函数的作用？在C++上有除了多态特性，还有什么作用？问到了虚函数的析构函数。</li><li><p>函数的显示转换，然后我回答了显示转换和隐式转换</p></li><li><p>多线程有哪些东西是多线程自己的？如堆栈、寄存器。还有什么，我没回答上来。</p></li><li>内存分配用什么？？我回答的malloc和new,面试官说还有一个，我没回答上来。</li><li>网络知识<br>TCP/IP的四次握手，问到了time_wait()函数<br>Linux指令</li><li>数据库<br>MySQL的数据结构是啥？</li><li>其他<br>看过和研究过开源源码没？<br>搭建的博客使用的什么语言？<br>之前用过腾讯云的哪些产品？</li></ul><p>还问了一个智力题，有8瓶水，一瓶有毒，小白鼠尝几次才会尝出那杯毒水？一小时后中毒</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>C++基础知识需要进一步的灵活运用，掌握很多语法的设计思路</li><li>读开源代码，写对代码的理解与认识，代码是怎么实现其算法思想的？</li><li>对尝试新应用时，不能只想着怎么会用？要理解其设计模式、架构及怎么表现出来的。如搭建博客后，要弄清楚其实现，使用的语言等。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先进行自我介绍！&lt;br&gt;因为刚开始通话时，我已做过自我介绍。所以，在进行自我介绍时，我介绍了一下我做的3个项目。&lt;br&gt;然后，面试官说对第一个项目比较感兴趣，我就开始介绍。介绍完之后，我说到了流量控制，然后面试官问到了netfilter的几个函数。&lt;br&gt;我简要的说有几个
      
    
    </summary>
    
      <category term="工作" scheme="https://wonderxiao.github.io/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="面试" scheme="https://wonderxiao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>python中的正则表达式</title>
    <link href="https://wonderxiao.github.io/2018/01/27/python%E4%B8%AD%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://wonderxiao.github.io/2018/01/27/python中的正则表达式/</id>
    <published>2018-01-27T12:27:02.000Z</published>
    <updated>2018-05-08T02:12:30.112Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式中常用字符含义"><a href="#正则表达式中常用字符含义" class="headerlink" title="正则表达式中常用字符含义"></a>正则表达式中常用字符含义</h2><ol><li>普通字符和11个元字符：</li></ol><table><thead><tr><th style="text-align:center">普通字符</th><th style="text-align:left">匹配自身</th><th style="text-align:center">abc</th><th style="text-align:center">abc </th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:left">匹配任意除换行符”\n”外的字符</td><td style="text-align:center">a.c</td><td style="text-align:center">abc   </td></tr><tr><td style="text-align:center">\</td><td style="text-align:left">转义字符，使后一个字符改变原来的意思</td><td style="text-align:center">a.c;a\c</td><td style="text-align:center">a.c;a\c    </td></tr><tr><td style="text-align:center">*</td><td style="text-align:left">匹配前一个字符0或多次</td><td style="text-align:center">abc*</td><td style="text-align:center">ab;abc;cc  </td></tr><tr><td style="text-align:center">+</td><td style="text-align:left">匹配一个字符1次或无限次</td><td style="text-align:center">abc+</td><td style="text-align:center">abc;abccc</td></tr><tr><td style="text-align:center">?</td><td style="text-align:left">匹配一个字符0次或1次</td><td style="text-align:center">abc?</td><td style="text-align:center">ab;abc</td></tr><tr><td style="text-align:center">^</td><td style="text-align:left">匹配字符串开头，在多行模式中匹配每行的开头</td><td style="text-align:center">^abc</td><td style="text-align:center">abc</td></tr><tr><td style="text-align:center">$</td><td style="text-align:left">匹配字符串末尾，在多行模式中匹配每行的末尾</td><td style="text-align:center">abc$</td><td style="text-align:center">abc</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:left">或，匹配&#124;左右表达式任意一个，从左到右匹配，若&#124;没有包括在（）中，则它的范围是整个正则表达式</td><td style="text-align:center">abc&#124;def</td><td style="text-align:center">abcdef</td></tr><tr><td style="text-align:center">{}</td><td style="text-align:left">{m}匹配前一个字符m次，{m,n}匹配前一个字符m~n次，若省略n，则匹配m至无限次</td><td style="text-align:center">ab{1,2}c</td><td style="text-align:center">abc;abbbc</td></tr><tr><td style="text-align:center">[]</td><td style="text-align:left">字符集，对应的位置可以是字符集中的任意字符，字符集中的字符可逐个列出，也可给出范围，如[abc]或[a-c]，[^abc]表示取反，即非abc。所有特殊字符在字符集都失去其特殊含义，用\转义恢复其特殊含义</td><td style="text-align:center">a[bcd]e</td><td style="text-align:center">abe;ace;ade</td></tr><tr><td style="text-align:center">()</td><td style="text-align:left">被阔起来的表达式作为分组，从表达式左边开始没遇到一个分组的左括号”(“，编号+1，分组表达式作为一个整体，可接数量词。表达式中的&#124;仅在该组有效</td><td style="text-align:center">(abc){2};a(123&#124;456)c</td><td style="text-align:center">abcabc;a456c</td></tr></tbody></table><h3 id="反斜杠作用："><a href="#反斜杠作用：" class="headerlink" title="反斜杠作用："></a>反斜杠作用：</h3><ul><li>后跟元字符去除特殊功能，如特殊字符转义成普通字符</li><li>后跟普通字符实现特殊功能，如预定义字符</li><li>引号序列对应字组所匹配的字符串</li></ul><p>2.预定义字符集</p><table><thead><tr><th style="text-align:center">普通字符</th><th style="text-align:left">字符含义</th><th style="text-align:center">abc</th><th style="text-align:center">abc </th></tr></thead><tbody><tr><td style="text-align:center">\d</td><td style="text-align:left">数字：[0-9]</td><td style="text-align:center">a\bc</td><td style="text-align:center">a1c</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:left">非数字：[^\d]</td><td style="text-align:center">a\Dc</td><td style="text-align:center">abc</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:left">匹配任何空白字符：[&lt;空格&gt;\t\r\n\f\v]</td><td style="text-align:center">a\sc</td><td style="text-align:center">a c</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:left">匹配包括下划线在内的任何字符：[A-Za-z0-9_]</td><td style="text-align:center">a\wc</td><td style="text-align:center">abc</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:left">匹配非字母字符，即匹配特殊字符</td><td style="text-align:center">a\Wc</td><td style="text-align:center">a c</td></tr><tr><td style="text-align:center">\A</td><td style="text-align:left">仅匹配字符串开头，同^</td><td style="text-align:center">\Aabc</td><td style="text-align:center">abc</td></tr><tr><td style="text-align:center">\Z</td><td style="text-align:left">仅匹配字符串结尾，同$</td><td style="text-align:center">abc\Z</td><td style="text-align:center">abc</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:left">匹配\w和\W之间，即匹配一个单词边界，也就是单词和空格间的位置，如’er\b’可匹配’never’中的’er’，但不能匹配’verb’中的’er’</td><td style="text-align:center">\babc\b;a\b!bc</td><td style="text-align:center">空格abc;空格a!bc</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:left">[^\b]</td><td style="text-align:center">a\Bbc</td><td style="text-align:center">abc</td></tr></tbody></table><p>3.特殊分组用法</p><table><thead><tr><th style="text-align:center">普通字符</th><th style="text-align:left">字符含义</th><th style="text-align:center">abc</th><th style="text-align:center">abc </th></tr></thead><tbody><tr><td style="text-align:center">(?P&lt;name&gt;)</td><td style="text-align:left">分组除了原有的编号外再指定一个额外的别名</td><td style="text-align:center">(?P&lt;id&gt;abc){2}</td><td style="text-align:center">abcabc                          </td></tr><tr><td style="text-align:center">(?P=name)</td><td style="text-align:left">引用别名为\<name>的分组匹配到字符串</name></td><td style="text-align:center">(?P&lt;id&gt;\d)abc(?P=id)</td><td style="text-align:center">1abc15abc5</td></tr><tr><td style="text-align:center">&lt;number&gt;</td><td style="text-align:left">引用编号为\<number>的分组匹配到字符串</number></td><td style="text-align:center">(\d)abc\1</td><td style="text-align:center">1abc15abc5</td></tr></tbody></table><h2 id="re模块中的常用函数"><a href="#re模块中的常用函数" class="headerlink" title="re模块中的常用函数"></a>re模块中的常用函数</h2><p>1.compile()<br>编译正则表达式模式，返回一个对象模式<br>格式：re.compile(pattern,flags=0)<br>pattern:编译时用的字符串表达式<br>flags:编译标志位，用于修改正则表达式的匹配方式，如是否区分大小写，多行匹配等。</p><p><strong>常用flags:</strong> </p><table><thead><tr><th style="text-align:center">标志</th><th style="text-align:left">含义                              </th></tr></thead><tbody><tr><td style="text-align:center">re.S(DOTALL)</td><td style="text-align:left">使匹配包括换行在内的所有字符</td></tr><tr><td style="text-align:center">re.I(IGNORECASE)</td><td style="text-align:left">使匹配对大小写不敏感</td></tr><tr><td style="text-align:center">re.L(LOCALE)</td><td style="text-align:left">做本地化识别(locale-aware)匹配</td></tr><tr><td style="text-align:center">re.M(MULTILINE)</td><td style="text-align:left">多行匹配，影响^和$</td></tr><tr><td style="text-align:center">re.X(VERBOSE)</td><td style="text-align:left">该标志通过给予灵活的格式以使正则表达式写得更易于被理解</td></tr><tr><td style="text-align:center">re.U</td><td style="text-align:left">根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">tt = <span class="string">"It is a good and cool day!"</span></div><div class="line">rr = re.compile(<span class="string">r'\w*oo\w*'</span>)</div><div class="line">print(rr.findall(tt)) <span class="comment">#查找所有包含'oo'的单词</span></div><div class="line"></div><div class="line">执行结果：</div><div class="line">[<span class="string">'good'</span>,<span class="string">'cool'</span>]</div></pre></td></tr></table></figure><ol><li>match()</li></ol><p>决定RE是否在字符串刚开始的位置匹配<br>该方法并不是完全匹配，当pattern结束后，若string还有剩余字符，仍视为成功。若要完全匹配，则在表达式末尾加上边界匹配符’$’<br>格式：re.match(pattern,string,flags=0)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">print(re.match(<span class="string">'com'</span>,<span class="string">'comwww.runcomoob'</span>).group())</div><div class="line">print(re.match(<span class="string">'com'</span>,<span class="string">'Comwww.runcomoob'</span>,re.I).group())</div><div class="line"></div><div class="line">执行结果：</div><div class="line">com</div><div class="line">com</div></pre></td></tr></table></figure></p><ol><li>search()</li></ol><p>格式：re.search(pattern,string,flags=0)<br>re.search函数会在字符串内查找模式匹配，只要找到第一个匹配然后返回，若字符串没有匹配，则返回None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(re.search(<span class="string">'\dcom'</span>,<span class="string">'www.4comrunoob.5com'</span>).group())</div><div class="line"></div><div class="line">执行结果：</div><div class="line"><span class="number">2</span>com</div></pre></td></tr></table></figure><p>match和search一旦匹配成功，就是一个match object对象，而match object对象有以下方法：</p><ul><li>group() 返回被 RE 匹配的字符串</li><li>start() 返回匹配开始的位置</li><li>end() 返回匹配结束的位置</li><li>span() 返回一个元组包含匹配 (开始,结束) 的位置</li><li>group() 返回re整体匹配的字符串，可以一次输入多个组号，对应组号匹配的字符串</li></ul><p><strong>a.group()</strong><br>返回re整体匹配的字符串，</p><p><strong>b.group(n,m)</strong><br>返回组号为n，m所匹配的字符串，如果组号不存在，则返回indexError异常</p><p><strong>c.groups()</strong><br>返回一个包含正则表达式中所有小组字符串的元组，从 1 到所含的小组号，通常groups()不需要参数，返回一个元组，元组中的元就是正则表达式中定义的组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">a = <span class="string">"123abc456"</span></div><div class="line">print(re.search(<span class="string">"([0-9]*)([a-z]*)([0-9]*)"</span>,a).group(<span class="number">0</span>))   <span class="comment">#123abc456,返回整体</span></div><div class="line">print(re.search(<span class="string">"([0-9]*)([a-z]*)([0-9]*)"</span>,a).group(<span class="number">1</span>))   <span class="comment">#123</span></div><div class="line">print(re.search(<span class="string">"([0-9]*)([a-z]*)([0-9]*)"</span>,a).group(<span class="number">2</span>))   <span class="comment">#abc</span></div><div class="line">print(re.search(<span class="string">"([0-9]*)([a-z]*)([0-9]*)"</span>,a).group(<span class="number">3</span>))   <span class="comment">#456</span></div><div class="line"><span class="comment">#group(1) 列出第一个括号匹配部分</span></div><div class="line"><span class="comment">#group(2) 列出第二个括号匹配部分</span></div><div class="line"><span class="comment">#group(3) 列出第三个括号匹配部分</span></div></pre></td></tr></table></figure><ol><li>findall()<br>re.findall遍历匹配，可获取字符串中所有匹配的字符串，返回一个列表<br>格式：re.findall(pattern,string,flags=0)<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">p = re.compile(<span class="string">r'\d+'</span>)</div><div class="line">print(p.findall(<span class="string">'o1n2m3k4'</span>))</div><div class="line"></div><div class="line">执行结果如下：</div><div class="line">[<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</div></pre></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">tt = <span class="string">"Tina is a good girl, she is cool, clever, and so on..."</span></div><div class="line">rr = re.compile(<span class="string">r'\w*oo\w*'</span>)</div><div class="line">print(rr.findall(tt))</div><div class="line">print(re.findall(<span class="string">r'(\w)*oo(\w)'</span>,tt))<span class="comment">#()表示子表达式 </span></div><div class="line"></div><div class="line">执行结果如下：</div><div class="line">[<span class="string">'good'</span>, <span class="string">'cool'</span>]</div><div class="line">[(<span class="string">'g'</span>, <span class="string">'d'</span>), (<span class="string">'c'</span>, <span class="string">'l'</span>)]</div></pre></td></tr></table></figure><ol><li>finditer()<br>搜索string，返回一个顺序访问每一个匹配结果(Match对象)的迭代器，找到RE匹配的所有子串，并把它们作为一个迭代器返回<br>格式：re.finditer(pattern,string,flags=0)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">iter = re.finditer(<span class="string">r'\d+'</span>,<span class="string">'12 drumm44ers drumming, 11 ... 10 ...'</span>)</div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> iter:</div><div class="line">    print(i)</div><div class="line">    print(i.group())</div><div class="line">    print(i.span())</div><div class="line"></div><div class="line">执行结果如下：</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">0</span>, <span class="number">2</span>), match=<span class="string">'12'</span>&gt;</div><div class="line"><span class="number">12</span></div><div class="line">(<span class="number">0</span>, <span class="number">2</span>)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">8</span>, <span class="number">10</span>), match=<span class="string">'44'</span>&gt;</div><div class="line"><span class="number">44</span></div><div class="line">(<span class="number">8</span>, <span class="number">10</span>)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">24</span>, <span class="number">26</span>), match=<span class="string">'11'</span>&gt;</div><div class="line"><span class="number">11</span></div><div class="line">(<span class="number">24</span>, <span class="number">26</span>)</div><div class="line">&lt;_sre.SRE_Match object; span=(<span class="number">31</span>, <span class="number">33</span>), match=<span class="string">'10'</span>&gt;</div><div class="line"><span class="number">10</span></div><div class="line">(<span class="number">31</span>, <span class="number">33</span>)</div></pre></td></tr></table></figure><ol><li>split()<br>按照能够匹配的子串将string分割后返回列表，可使用re.split来分割字符串，如re.split(r’\s+’,text)来将字符串按空格分割成一个单词列表<br>格式：re.split(pattern,string[, maxsplit])<br>maxsplit用于指定最大分割次数，不指定将全部分割</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(re.split(<span class="string">'\d+'</span>,<span class="string">'one1two2three3four4five5'</span>))</div><div class="line"></div><div class="line">执行结果如下：</div><div class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>, <span class="string">''</span>]</div></pre></td></tr></table></figure><ol><li>sub()<br>使用re替换string中每一个匹配的子串后返回替换后的字符串<br>格式：re.sub(pattern,repl,string,count)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> re</div><div class="line">text = <span class="string">"JGood is a handsome boy, he is cool, clever, and so on..."</span></div><div class="line">print(re.sub(<span class="string">r'\s+'</span>, <span class="string">'-'</span>, text))</div><div class="line"></div><div class="line">执行结果如下：</div><div class="line">JGood-<span class="keyword">is</span>-a-handsome-boy,-he-<span class="keyword">is</span>-cool,-clever,-<span class="keyword">and</span>-so-on...</div><div class="line">其中第二个函数是替换后的字符串；本例中为<span class="string">'-'</span></div><div class="line">第四个参数指替换个数。默认为<span class="number">0</span>，表示每个匹配项都替换</div><div class="line">``` </div><div class="line"></div><div class="line">re.sub还允许使用函数对匹配项的替换进行复杂处理，如</div><div class="line">re.sub(<span class="string">r'\s'</span>, <span class="keyword">lambda</span> m:<span class="string">'['</span> + m.group(<span class="number">0</span>) + <span class="string">']'</span>,text,<span class="number">0</span>)将字符串中的空格<span class="string">' '</span>替换为<span class="string">'[]'</span></div><div class="line">``` python</div><div class="line"><span class="keyword">import</span> re</div><div class="line">text = <span class="string">"JGood is a handsome boy, he is cool, clever, and so on..."</span></div><div class="line">print(re.sub(<span class="string">r'\s+'</span>, <span class="keyword">lambda</span> m:<span class="string">'['</span>+m.group(<span class="number">0</span>)+<span class="string">']'</span>, text,<span class="number">0</span>))</div><div class="line"></div><div class="line">执行结果如下：</div><div class="line">JGood[ ]<span class="keyword">is</span>[ ]a[ ]handsome[ ]boy,[ ]he[ ]<span class="keyword">is</span>[ ]cool,[ ]clever,[ ]<span class="keyword">and</span>[ ]so[ ]on...</div></pre></td></tr></table></figure><ol><li>subn()<br>返回替换次数<br>格式：subn(pattern,repl,string,count=0,flags=0)</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">print(re.subn(<span class="string">'[1-2]'</span>,<span class="string">'A'</span>,<span class="string">'123456abcdef'</span>))</div><div class="line">print(re.sub(<span class="string">"g.t"</span>,<span class="string">"have"</span>,<span class="string">'I get A,  I got B ,I gut C'</span>))</div><div class="line">print(re.subn(<span class="string">"g.t"</span>,<span class="string">"have"</span>,<span class="string">'I get A,  I got B ,I gut C'</span>))</div><div class="line"></div><div class="line">执行结果如下：</div><div class="line">(<span class="string">'AA3456abcdef'</span>, <span class="number">2</span>)</div><div class="line">I have A,  I have B ,I have C</div><div class="line">(<span class="string">'I have A,  I have B ,I have C'</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure><h3 id="re-match与re-search与re-findall区别："><a href="#re-match与re-search与re-findall区别：" class="headerlink" title="re.match与re.search与re.findall区别："></a>re.match与re.search与re.findall区别：</h3><p>re.match只匹配字符串的开始，如字符串开始不符合正则表达式，则匹配失败，函数返回None;<br>re.search匹配整个字符串，直到找到一个匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">a=re.search(<span class="string">'[\d]'</span>,<span class="string">"abc33"</span>).group()</div><div class="line">print(a)</div><div class="line">p=re.match(<span class="string">'[\d]'</span>,<span class="string">"abc33"</span>)</div><div class="line">print(p)</div><div class="line">b=re.findall(<span class="string">'[\d]'</span>,<span class="string">"abc33"</span>)</div><div class="line">print(b)</div><div class="line"></div><div class="line">执行结果：</div><div class="line"><span class="number">3</span></div><div class="line"><span class="keyword">None</span></div><div class="line">[<span class="string">'3'</span>, <span class="string">'3'</span>]</div></pre></td></tr></table></figure><h3 id="贪婪匹配与非贪婪匹配"><a href="#贪婪匹配与非贪婪匹配" class="headerlink" title="贪婪匹配与非贪婪匹配"></a>贪婪匹配与非贪婪匹配</h3><p>*?,+?,??,{m,n}?<br>前面*,+,?等都是贪婪匹配，即尽可能匹配，后面加?号使其变成惰性匹配<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = re.findall(<span class="string">r"a(\d+?)"</span>,<span class="string">'a23b'</span>)</div><div class="line">print(a)</div><div class="line">b = re.findall(<span class="string">r"a(\d+)"</span>,<span class="string">'a23b'</span>)</div><div class="line">print(b)</div><div class="line"></div><div class="line">执行结果：</div><div class="line">[<span class="string">'2'</span>]</div><div class="line">[<span class="string">'23'</span>]</div></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">a = re.match(<span class="string">'&lt;(.*)&gt;'</span>,<span class="string">'&lt;H1&gt;title&lt;H1&gt;'</span>).group()</div><div class="line">print(a)</div><div class="line">b = re.match(<span class="string">'&lt;(.*?)&gt;'</span>,<span class="string">'&lt;H1&gt;title&lt;H1&gt;'</span>).group()</div><div class="line">print(b)</div><div class="line"></div><div class="line">执行结果：</div><div class="line">&lt;H1&gt;title&lt;H1&gt;</div><div class="line">&lt;H1&gt;</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">a = re.findall(<span class="string">r"a(\d+)b"</span>,<span class="string">'a3333b'</span>)</div><div class="line">print(a)</div><div class="line">b = re.findall(<span class="string">r"a(\d+?)b"</span>,<span class="string">'a3333b'</span>)</div><div class="line">print(b)</div><div class="line"></div><div class="line">执行结果如下：</div><div class="line">[<span class="string">'3333'</span>]</div><div class="line">[<span class="string">'3333'</span>]</div><div class="line">若前后均有限定条件的时候，就不存在什么贪婪模式了，非匹配模式失效</div></pre></td></tr></table></figure><h3 id="用flags时应注意："><a href="#用flags时应注意：" class="headerlink" title="用flags时应注意："></a>用flags时应注意：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">print(re.split(<span class="string">'a'</span>,<span class="string">'1A1a2A3'</span>,re.I))<span class="comment">#输出结果并未能区分大小写</span></div><div class="line"><span class="comment">#re.split(pattern，string，maxsplit,flags)默认是四个参数</span></div><div class="line">当我们传入的三个参数的时候，系统会默认re.I是第三个参数，所以就没起作用</div><div class="line">如果想让这里的re.I起作用，写成flags=re.I即可</div></pre></td></tr></table></figure><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li>匹配电话号码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p = re.compile(<span class="string">r'\d&#123;3&#125;-\d&#123;6&#125;'</span>)</div><div class="line">print(p.findall(<span class="string">'010-628888'</span>))</div></pre></td></tr></table></figure><ul><li>匹配IP<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">re.search(r<span class="string">"(([01]?\d?\d|2[0-4]\d|25[0-5])\.)&#123;3</span></div><div class="line"><span class="string">&#125;([01]?\d?\d|2[0-4]\d|25[0-5]\.)"</span>,<span class="string">"192.168.1.1"</span>)</div></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;正则表达式中常用字符含义&quot;&gt;&lt;a href=&quot;#正则表达式中常用字符含义&quot; class=&quot;headerlink&quot; title=&quot;正则表达式中常用字符含义&quot;&gt;&lt;/a&gt;正则表达式中常用字符含义&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;普通字符和11个元字符：&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="python" scheme="https://wonderxiao.github.io/categories/python/"/>
    
    
      <category term="正则表达式" scheme="https://wonderxiao.github.io/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>NEXX WT3020F路由器刷机</title>
    <link href="https://wonderxiao.github.io/2017/12/23/NEXX-WT3020F%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%B7%E6%9C%BA/"/>
    <id>https://wonderxiao.github.io/2017/12/23/NEXX-WT3020F路由器刷机/</id>
    <published>2017-12-22T21:03:01.000Z</published>
    <updated>2018-05-08T02:09:38.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NEXX-WT3020F介绍"><a href="#NEXX-WT3020F介绍" class="headerlink" title="NEXX WT3020F介绍"></a>NEXX WT3020F介绍</h2><ul><li>小型mini路由器</li><li>使用MediaTek MT7620n芯片</li><li>一个WAN端口、一个LAN端口</li><li>802.11n 2T/2R 2.4GHz 300Mbps无线接入</li><li>支持3G/4G接入</li></ul><p><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-12-22_NEXX3020F.jpg" alt="NEXX WT3020F原始图"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">/bin<span class="comment"># cat /proc/cpuinfo</span></div><div class="line">system <span class="built_in">type</span>             : MediaTek MT7620N ver:2 eco:6</div><div class="line">machine                 : Nexx WT3020</div><div class="line">processor               : 0</div><div class="line">cpu model               : MIPS 24KEc V5.0</div><div class="line">BogoMIPS                : 385.84</div><div class="line"><span class="built_in">wait</span> instruction        : yes</div><div class="line">microsecond timers      : yes</div><div class="line">tlb_entries             : 32</div><div class="line">extra interrupt vector  : yes</div><div class="line">hardware watchpoint     : yes, count: 4, address/irw mask: [0x0ffc, 0x0ffc, 0x0ffb, 0x0ffb]</div><div class="line">isa                     : mips1 mips2 mips32r1 mips32r2</div><div class="line">ASEs implemented        : mips16 dsp</div><div class="line">shadow register sets    : 1</div><div class="line">kscratch registers      : 0</div><div class="line">package                 : 0</div><div class="line">core                    : 0</div><div class="line">VCED exceptions         : not available</div><div class="line">VCEI exceptions         : not available</div></pre></td></tr></table></figure><h2 id="刷OpenWrt固件"><a href="#刷OpenWrt固件" class="headerlink" title="刷OpenWrt固件"></a>刷OpenWrt固件</h2><ul><li>连接路由器<br>使用secureCRT通过telnet连接到路由器后台，该连接中网络端口需连LAN口<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ telnet 192.168.8.1</div><div class="line"></div><div class="line">(none) login: nexxadmin</div><div class="line">Password:y1n2inc.com0755</div></pre></td></tr></table></figure></li></ul><p>之后，就可在路由器上进行操作管理</p><ul><li><p>备份官方固件</p><ul><li><p>查看当前系统分区信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cat /proc/mtd</span></div><div class="line">dev:    size   erasesize  name</div><div class="line">mtd0: 00030000 00010000 <span class="string">"Bootloader"</span></div><div class="line">mtd1: 00010000 00010000 <span class="string">"Config"</span></div><div class="line">mtd2: 00010000 00010000 <span class="string">"Factory"</span></div><div class="line">mtd3: 007b0000 00010000 <span class="string">"Kernel"</span></div></pre></td></tr></table></figure><p>将mtd0~mtd3都备份到U盘中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cd /media/sda/sda4</span></div><div class="line">cp /dev/mtd0 &gt; mtd0.bin</div><div class="line">cp /dev/mtd1 &gt; mtd1.bin</div><div class="line">cp /dev/mtd2 &gt; mtd2.bin</div><div class="line">cp /dev/mtd3 &gt; mtd3.bin</div></pre></td></tr></table></figure><p>备份好之后，就可开始进行固件刷入了</p></li></ul></li><li><p>OpenWrt固件刷入<br>本人使用<a href="https://downloads.openwrt.org/chaos_calmer/15.05-rc3/ramips/mt7620/openwrt-15.05-rc3-ramips-mt7620-wt3020-8M-squashfs-factory.bin" target="_blank" rel="external">WT3020F Fireware Openwrt Install</a>安装包进行固件刷入</p></li></ul><ol><li>按上述链接下载固件二进制文件</li><li>使用电脑连接WLAN或通过LAN连接到路由器</li><li>打开浏览器输入”192.168.8.1”，用户名：admin，密码：admin</li><li>进入高级设置-&gt;配置管理-&gt;软件升级</li><li>选择刚下载好的固件二进制文件，进行升级</li><li>一段时间后，可看到系统重启，需重新连接路由器</li></ol><p>此时，通过”192.168.1.1”，发现并登录不了路由器的WEB界面？？怎么办？<br>当刷完路由器固件后，使用SSH或TTL终端能接入路由器，这时需要安装WEB管理界面LuCY</p><ol><li>打开路由器linux终端，输入：<br>opkg update    开始下载Packages.gz并更新</li><li>输入：<br>opkg install luci    安装LuCY主体，先开始自动下载各种关联库，下载完会自动安装配置；</li><li>输入：<br>/etc/init.d/uhttpd enable    打开uhttpd服务；</li><li>输入：<br>/etc/init.d/uhttpd start    让uhttpd自启动；</li><li>在电脑端中国浏览器上输入”192.168.1.1”，可访问路由器就表示LuCY安装成功</li></ol><p>原来的编译的luci是没有这个挂载点的，如下命令增加挂载点：<br>opkg update<br>opkg install block-mount<br>重启路由即可出现 挂载点</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;NEXX-WT3020F介绍&quot;&gt;&lt;a href=&quot;#NEXX-WT3020F介绍&quot; class=&quot;headerlink&quot; title=&quot;NEXX WT3020F介绍&quot;&gt;&lt;/a&gt;NEXX WT3020F介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;小型mini路由器&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="路由器" scheme="https://wonderxiao.github.io/categories/%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
    
      <category term="OpenWrt" scheme="https://wonderxiao.github.io/tags/OpenWrt/"/>
    
  </entry>
  
  <entry>
    <title>内存四区</title>
    <link href="https://wonderxiao.github.io/2017/11/01/%E5%86%85%E5%AD%98%E5%9B%9B%E5%8C%BA/"/>
    <id>https://wonderxiao.github.io/2017/11/01/内存四区/</id>
    <published>2017-11-01T15:33:11.000Z</published>
    <updated>2018-05-04T13:50:37.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>内存四区包含静态区、代码区、堆区、栈区</p><blockquote><p>静态区</p></blockquote><p>全局变量和静态变量存储在静态区</p><blockquote><p>堆区</p></blockquote><p>malloc的变量放在堆区，堆区一般由程序员分配释放。若程序员不释放，程序结束时可由操作系统回收。其分配方式类似于链表，在内存中的分布不是连续的，它们是不同区域的内存块通过指针链接起来的。一旦某一节点从链中断开，我们就要人为的将断开的节点从内存中释放。</p><ul><li>堆的增长方式<br>由低地址向高地址<blockquote><p>栈区</p></blockquote></li></ul><p>局部变量存在栈区，由编译器自动分配释放，存放函数的参数值、局部变量的值。其操作方式类似数组，它的内存分配是连续分配的，即分配的内存是一块连续的内存区域。当声明变量时，编译器会自动接着当前栈区的结尾继续分配内存。</p><ul><li>栈的增长方式<br>由高地址向低地址，函数参数载入时由右向左<blockquote><p>常量区</p></blockquote></li></ul><p>常量字符串存放于此，程序结束后由系统自动释放</p><blockquote><p>代码区</p></blockquote><p>存放函数体的二进制代码<br>一个正常的程序在内存中通常分为程序段、数据段和堆栈三部分。程序段放着程序的机器码、只读数据。这个段通常是只读，对它的写操作是非法的。数据段放的是程序中的静态数据，动态数据则通过堆栈来存放。</p><p>内存低端——-<br>   <strong>程序段</strong><br>   <strong>数据段</strong><br>   <strong>堆  栈</strong><br>内存高端——-</p><blockquote><p>堆栈是内存中的一个连续的块，一个叫堆栈指针的寄存器（SP）指向堆栈的栈顶，堆栈的底部是一个固定地址。堆栈有一个特点就是，后进先出。也就是说，后放入的数据第一个取出。它支持两个操作，PUSH和POP。PUSH是将数据放到栈的顶端，POP是将栈顶的数据取出。</p><p>在高级语言中，程序函数调用、函数中的临时变量都用到堆栈。为什么呢？因为在调用一个函数时，我们需要对当前的操作进行保护，也为了函数执行后，程序可以正确的找到地方继续执行，所以参数的传递和返回值也用到了堆栈。</p><p>通常对局部变量的引用是通过给出它们对SP的偏移量来实现的，另外还有一个基址指针（FP，在Intel芯片中是BP），许多编译器实际上是用它来引用本地变量和参数的。<br>通常，参数的相对FP的偏移是正的，局部变量是负的。 </p><p>当程序中发生函数调用时，计算机做如下操作：首先把参数压入堆栈；然后保存指令寄存器(IP)中的内容，做为返回地址(RET)；第三个放入堆栈的是基址寄存器(FP)；然后把当前的栈指针(SP)拷贝到FP，做为新的基地址；最后为本地变量留出一定空间，把SP减去适当的数值。    </p></blockquote><h2 id="堆和栈的基础知识"><a href="#堆和栈的基础知识" class="headerlink" title="堆和栈的基础知识"></a>堆和栈的基础知识</h2><h3 id="申请方式"><a href="#申请方式" class="headerlink" title="申请方式"></a>申请方式</h3><ul><li>栈<br>系统自动分配，声明局部变量int b;<br>系统自动在栈中为b分配空间</li><li>堆<br>程序员自己申请，并指明大小，在C中使用malloc函数，如p1 = (char *)malloc(10);<br>在C++中使用new运算符。但是，p1和p2本身是在栈中存储的。<h3 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h3></li><li>栈<br>只要栈的剩余空间大于所申请的空间，系统就为程序提供内存，否则将异常提示栈溢出</li><li>堆<br>在操作系统中，有一个记录空闲内存地址的链表。当系统收到程序申请内存空间时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对大多数系统来说，会在这块内存空间的首地址处记录本次分配的大小。这样，代码中的delete语句才能释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统自动会将多余的那部分重新放入空闲链表中。<h3 id="申请大小的限制"><a href="#申请大小的限制" class="headerlink" title="申请大小的限制"></a>申请大小的限制</h3></li><li>栈<br>在Windows中，栈是向低地址扩展的数据结构，是一块连续的内存区域，即栈顶的地址和栈的最大容量是系统预先规定好的。在Windows下，栈的大小是2M（它是编译时就确定的常数）。若申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</li><li>堆<br>堆是向高地址扩展的数据结构，是不连续的内存区域。由于系统是用链表来存储空闲的内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆得大小受限于计算机系统中有效的虚拟内存。由此可知，堆获得的空间比较灵活，也比较大。<h3 id="申请效率的比较"><a href="#申请效率的比较" class="headerlink" title="申请效率的比较"></a>申请效率的比较</h3></li><li>栈<br>由系统自动分配，速度较快，但程序员无法控制。</li><li>堆<br>用户由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来方便。</li></ul><p>在Windows下，最好的方式是用VirtualAlloc分配内存，它不在堆，也不在栈，是直接在进程的地址空间中保留一块内存。虽然用起来最不方便，但是速度快，也最灵活。</p><h3 id="堆和栈的存储内容"><a href="#堆和栈的存储内容" class="headerlink" title="堆和栈的存储内容"></a>堆和栈的存储内容</h3><hr><ul><li>栈<br>在函数调用时，第一个进栈的是主函数中被调函数的下一条可执行语句的地址。然后是函数的各个参数，在大多数C编译器中，参数是由右往左入栈的，接着是函数中的局部变量。其中，静态变量是不入栈的。<br>当本次函数调用结束后，局部变量先出栈，然后是函数参数，最后是栈顶指针指向最开始存的地址，即主函数中的下一条指令，程序由该点继续往下执行。</li><li>堆<br>一般是在堆得头部用一个字节存放堆得大小，堆中具体内容由程序员安排。<h3 id="存取效率的比较"><a href="#存取效率的比较" class="headerlink" title="存取效率的比较"></a>存取效率的比较</h3></li></ul><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> s1[] = <span class="string">"aaaaaaaa"</span>;</div><div class="line"><span class="keyword">char</span> *s2 = <span class="string">"bbbbb"</span>;</div></pre></td></tr></table></figure><blockquote><p>aaaaaaaa是在运行时进行赋值的，bbbbb是在编译时就确定了的。但是，在以后的存取中，在栈上的数组比指针所指向的字符串（如堆）快。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">char</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">char</span> c[] = <span class="string">"123456"</span>;</div><div class="line"><span class="keyword">char</span> *p = <span class="string">"123456"</span>;</div><div class="line">a = c[<span class="number">1</span>];</div><div class="line">a = p[<span class="number">1</span>];</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对应的汇编：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">10</span>: a = c[<span class="number">1</span>];   </div><div class="line"><span class="number">00401067</span> <span class="number">8</span>A <span class="number">4</span>D F1 mov cl,byte ptr [ebp<span class="number">-0F</span>h]   </div><div class="line"><span class="number">0040106</span>A <span class="number">88</span> <span class="number">4</span>D FC mov byte ptr [ebp<span class="number">-4</span>],cl   </div><div class="line"><span class="number">11</span>: a = p[<span class="number">1</span>];   </div><div class="line"><span class="number">0040106</span>D <span class="number">8B</span> <span class="number">55</span> EC mov edx,dword ptr [ebp<span class="number">-14</span>h]   </div><div class="line"><span class="number">00401070</span> <span class="number">8</span>A <span class="number">42</span> <span class="number">01</span> mov al,byte ptr [edx+<span class="number">1</span>]   </div><div class="line"><span class="number">00401073</span> <span class="number">88</span> <span class="number">45</span> FC mov byte ptr [ebp<span class="number">-4</span>],al</div></pre></td></tr></table></figure></p><p>第一种在读取时直接将字符串中的元素读到寄存器cl中，而第二种则先把指针值读取到edx中，再根据edx读取字符串。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>堆和栈的区别：<br>使用栈就如去饭店吃饭，只需点菜（申请内存），付钱并吃（使用），不必做扫尾等工作，好处是快捷，但自由度小；<br>使用堆就如自己做菜，做自己想吃的，自由行大；<br>这里的堆实际指满足堆性质的优先队列的一种数据结构，第一个元素有最高的优先权；栈实际上是满足先进后出的性质的数据结构。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;内存四区包含静态区、代码区、堆区、栈区&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态区&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全局变量和
      
    
    </summary>
    
      <category term="内存管理" scheme="https://wonderxiao.github.io/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="内存分配" scheme="https://wonderxiao.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>视频直播</title>
    <link href="https://wonderxiao.github.io/2017/10/28/%E8%A7%86%E9%A2%91%E7%9B%B4%E6%92%AD/"/>
    <id>https://wonderxiao.github.io/2017/10/28/视频直播/</id>
    <published>2017-10-27T20:41:24.000Z</published>
    <updated>2018-05-04T13:53:29.789Z</updated>
    
    <content type="html"><![CDATA[<p>整个直播流程分为几个关键步骤：</p><ul><li>主播客户端，将本地采集的视频推送到CDN</li><li>CDN对视频流进行缓存以及转发</li><li>观众客户端，拉取CDN中缓存的视频流进行播放<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-27_直播1.png" alt="直播架构"><h2 id="CDN技术原理"><a href="#CDN技术原理" class="headerlink" title="CDN技术原理"></a>CDN技术原理</h2>CDN全称为Content Delivery Network，即内容分发网络，是一个策略性部署的整体系统，主要用来解决由于网络带宽小、用户访问量大、网点分布不均与等导致用户访问网站速度慢的问题。<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-27_CDN%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="CDN架构"><br>从上可看出，通过增加新的一层网络架构，将网站的内容发布到离用户最近的网络节点上。这样，用户就可以就近获取所需内容，解决之前网络拥塞、访问延迟高的问题，提高用户体验。<br>对于直播业务来说，则将Web服务器换成主播客户端，如下图所示。<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-27_liveStructure.png" alt=""><br>由于视频占用带宽大，与普通Web服务差别较大，这样CDN优势更明显：<br>网络拥塞减少，访问延迟降低，带宽得到更好的控制。<h2 id="CDN直播中常用的流媒体协议"><a href="#CDN直播中常用的流媒体协议" class="headerlink" title="CDN直播中常用的流媒体协议"></a>CDN直播中常用的流媒体协议</h2></li><li>RTMP<br>Real Time Messaging Protocol，是基于TCP，由Adobe公司为Flash播放器和服务器之间音频、视频传输开发的开放协议</li><li>HLS<br>HTTP Live Streaming，是基于HTTP的，是Apple公司开放的音视频传输协议</li><li>HTTP FLV<br>将RTMP封装在HTTP协议之上的，可以更好的穿透防火墙等<blockquote><p>CDN主要包含源站、缓存服务器、智能DNS、客户端等几个主要组成部分。</p></blockquote></li><li>源站<br>发布内容的原始站点。添加、删除和更改网站的文件，都是在源站上进行的；另外缓存服务器所抓取的对象也全部来自于源站。对于直播来说，源站为主播客户端。</li><li>缓存服务器<br>直接提供给用户访问的站点资源，由一台或数台服务器组成；当用户发起访问时，他的访问请求被智能DNS定位到离他较近的缓存服务器。如果用户所请求的内容刚好在缓存里面，则直接把内容返还给用户；如果访问所需的内容没有被缓存，则缓存服务器向邻近的缓存服务器或直接向源站抓取内容，然后再返还给用户。</li><li>智能DNS<br>整个CDN技术的核心，它主要根据用户的来源，以及当前缓存服务器的负载情况等，将其访问请求指向离用户比较近且负载较小的缓存服务器。通过智能DNS解析，让用户访问同服务商下、负载较小的服务器，可以消除网络访问慢的问题，达到加速作用。</li><li>客户端<br>发起访问的普通用户。对于直播来说，就是观众客户端。<br>对于直播业务，CDN整体架构如下图所示：<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2014-10-27_CDN%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="CDN整体架构"></li><li>主要流程：</li></ul><ol><li>主播开始进行直播，向智能DNS发送解析请求；</li><li>智能DNS返回最优CDN节点IP地址；</li><li>主播端采集音视频数据，发送给CDN节点，CDN节点进行缓存等处理；</li><li>观众端要观看此主播的视频，向智能DNS发送解析请求；</li><li>智能DNS返回最优CDN节点IP地址；</li><li>观众端向CDN节点请求音视频数据；</li><li>CDN节点同步其他节点的音视频数据；</li><li>CDN节点将音视频数据发送给观众端；</li></ol><p>一提到直播，就会涉及到播放延时的问题，那么为什么会播放延时呢？</p><h3 id="1-网络延时"><a href="#1-网络延时" class="headerlink" title="1.网络延时"></a>1.网络延时</h3><p>网络延时是指从主播端采集，到观众端播放之间的时间差。这里不考虑主播端采集对视频进行编码的时间及观众端观看视频对解码的时间，仅考虑网络传输中的延时。<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-11-05_%E7%BD%91%E7%BB%9C%E6%97%B6%E5%BB%B6.png" alt="网络时延"><br>假设该链路上有缓存，时间应该添加缓存时间。另外，数据传输过程中还涉及到逻辑上的交互，例如包的重传以及确认，以及缓存上的一些逻辑等，会在这个基础上又增加很多。</p><p>在节点较少、网络情况较好的情况下，那么网络延时对应也是最小，加上一定的缓存，可以控制延时在1s~2s左右。但是节点多、网络差的情况下，网络延时会对应增大，经验来说延时可以达到15s以上。</p><h3 id="2-网络抖动"><a href="#2-网络抖动" class="headerlink" title="2.网络抖动"></a>2.网络抖动</h3><p>网络抖动，是指数据包的到达顺序、间隔和发出时不一致。比如说，发送100个数据包，每个包间隔1s发出。结果第27个包在传输过程中遇到网络拥塞，造成包27不是紧跟着26到达的，而是延迟到87后面才达。在直播中，这种抖动的效果实际上跟丢包是一样的。因为你不能依照接收顺序把内容播放出来，否则会造成失真。<br>134746<br><strong>网络抖动</strong>，会造成播放延时对应增大。如果网络中抖动较大，会造成播放卡顿等现象。具体情况如下图：<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-11-05_134746.png" alt=""><br>如上图，主播在t3和t5发出的包，分别在t3’和t5’到达，但中间延时较大，即发生了网络抖动，这样造成观众端观看视频的延时会不断增大。</p><h3 id="3-网络丢包"><a href="#3-网络丢包" class="headerlink" title="3.网络丢包"></a>3.网络丢包</h3><p>CDN直播中用到的RTMP、HLS、HTTP FLV等协议都是在TCP的基础之上。TCP一个很重要的特性是可靠性，即不会发生数据丢失的问题。为了保证可靠性，TCP在传输过程中有3次握手，见下图。首先客户端会向服务端发送连接请求，服务端同意后，客户端会确认这次连接。这就是3次握手。接着，客户端就开始发送数据，每次发送一批数据，得到服务端的“收到”确认后，继续发送下一批。TCP为了保证传到，会有自动重传机制。如果传输中发生了丢包，没有收到对端发出的“收到”信号，那么就会自动重传丢失的包，一直到超时。<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-05_%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85.png" alt="网络丢包"><br>由于互联网的网络状况是变化的，以及主播端的网络状况是无法控制的。所以当网络中丢包率开始升高时，重传会导致延时会不断增大，甚至导致不断尝试重连等情况，这样不能有效的缓存，严重情况下会导致观众端视频无法观看。</p><p>从底层协议和布网结构上，使用基于UDP协议的传输方案。SD-RTN（Software-Defined Real Time Net work），软件定义实时传输网络，是一种新型的专为内容实时传输而设计，基于UDP协议的网络架构。SD-RTN通过在互联网上不同地区的数据中心放置软件组网单元，相互连接互相调度，在现有的公共互联网基础上构建一层新的虚拟网络。能够实时根据各节点的连接、传输状况、负载状况、到用户的距离和响应时间，自动分配最优最通畅的传输路径，达到实时传输需要的质量保障级别。</p><p>CDN与SD-RTN对比情况：</p><ul><li>基本原理不同<br>CDN是存储转发结构，设计目的是在各个边缘节点缓存待分发内容，结构上从源站到观众是伞状多级缓存放大方式。SD-RTN本质上一个实时传输网络，用户的数据在网络单元内部和传输线路上都以实时交换方式传送，UDP实现的传输协议，不会因为前一个包的丢失或延迟导致下后续包的延迟送达，而丢包可以用对延迟更友好的方式修复或补偿出来，从而能够保证最低延迟。</li><li>底层协议不同<br>SD-RTN采用了专为实时传输设计的UDP协议，避免了采用TCP的延时不可控缺点。能够大大缩短交互延时，延时可从CDN方案的数秒，降低到数百毫秒。</li><li>内容分发机制不同<br>SD-RTN是基于自定义路由，选择最优传输路径，直接将内容端到端传输，数据在网络单元中从不缓存，从而最大可能的降低延迟，同时内容安全性也更好。CDN是将内容缓存于缓存服务器中，再将内容就近下发，所以CDN更适合做内容分发，一对多的场景。</li><li>使用场景不同<br>SD-RTN适用于要求极低时延的实时互动场景，例如网络电话、视频会议、有主播与观众交互需求的互动直播等。CDN适用于对时延要求不高的场景，例如对延时要求不高、类似电视的单点直播、网站加速等。<h3 id="SD-RTN的优势"><a href="#SD-RTN的优势" class="headerlink" title="SD-RTN的优势"></a>SD-RTN的优势</h3></li><li>时延大大缩短<br>直播延时可从基于TCP的方案的数秒，降低到数百毫秒。这一延迟范围，属于实时通信或准实时通信延迟的范畴。在这一级别上，主播和观众可以基本重现在现场活动中的交互体验，从而大大释放了内容制作者的潜力，也为业务运营者创造新业务形式打开了无限的空间和可能。</li><li>抗丢包能力强<br>SD-RTN中可以针对用户网络使用更多的策略模型和技术，这样在30%丢包时，依然能够进行正常直播。而基于TCP的直播方案在丢包2%时就明显卡顿，达到30%经常已断开连接，无法进行直播。</li></ul><p>直播中若要与用户交互，常见有两种方式：</p><ul><li>文字</li><li>连麦，主播可面对面与观众进行交互，增加互动性<h3 id="连麦分析"><a href="#连麦分析" class="headerlink" title="连麦分析"></a>连麦分析</h3></li></ul><ol><li>多路RTMP流实现<br>RTMP是目前主播最常用的协议，实现连麦方式若下图：<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-11-05_132424.png" alt=""><br>当有连麦者时，则主播端和连麦者端，都分别推一路RTMP流到CDN，CDN再将这两路RTMP流发送给观众端，观众端将两路RTMP流合成为一个画面。这种方式的优点是实现简单，但缺点比较多：</li></ol><ul><li>主播与连麦者如果要进行交互，则考虑到上面分析的延时问题，在这里延时需要至少加大一倍，这样对于实时交互来说，完全无法接受；</li><li>主播与连麦者交互时，声音会产生干扰，形成回音；</li><li>观众端要接收两条视频流，带宽、流量消耗过大，并且两路视频流解码播放，耗费CPU等资源也非常多；</li></ul><ol><li>主播端与连麦者P2P<br>主播端与连麦者之间使用P2P方式进行交互，然后主播端将自己和连麦者的视频进行合并，再推到CDN上，CDN再发送给观众端，如下图：<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-11-05_132701.png" alt=""></li></ol><ul><li>优点<br>主播和连麦者之间使用P2P，网络质量较好，延迟较小，保证了两者之间交互不会有非常大的延时<br>可以解决声音的干扰问题，消除回声</li><li>缺点<br>P2P在某些网络下无法穿透，有些观众根本无法与主播端进行交互;<br>主播端需要上传两路视频：一路P2P与连麦者进行交互，一路使用RTMP推到CDN。还要下载一路视频：连麦者P2P发送过来的交互数据。所以主播端要求带宽需要较高，网络较差时无法进行主播;<br>主播端要进行多路视频的编码、解码，要求主播端设备配置比较高，较差的设备也无法进行主播;<br>只能支持一个连麦者，不能支持多个连麦者;<br>由于主播端和连麦者经过CDN合并成一路，因此，不能实现主播端和连麦者视频大小窗口切换。</li></ul><ol><li>服务器端合图<br>主播和连麦者都将视频推送到CDN中，然后CDN内部对这几路视频进行合图，再将其发送给观众端。如下图：<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-11-05_133127.png" alt=""></li></ol><ul><li>优点<br>主播和连麦者各路视频都使用RTMP推送到CDN，可以保证延时较小；<br>由于CDN进行视频合图和发送，所以主播不需要很高的带宽；<br>由于CDN进行视频合图，所以主播的设备不需要配置非常高；<br>没有声音干扰问题；<br>可以支持多个连麦者连麦；</li><li>缺点<br>CDN需要进行视频的合图，需要额外开发工作，并且逻辑比较复杂；<br>CDN需要进行视频的合图，需要消耗较高服务器资源；<br>CDN合图后的布局难控制；<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3>使用SD-RTN，可以很好的解决多路RTMP、P2P连麦、服务器端合图这几种方案的弱势，并且开发难度降低，合图布局等都可以很好的在客户端上进行控制。<br>具体SD-RTN的架构可以参考下图：<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-11-05_133412.png" alt=""><br>客户端均通过UDP连接SD-RTN架构服务，通过SD-RTN的就近接入策略，让使用者就近接入质量最好的数据节点，经过传输延迟和质量优化的最优路径，自动避免网络拥塞和骨干网络故障的影响，将数据发送给其他客户端。若有常规的长延迟旁路直播，则可以将主播与连麦者合成一路直播流，通过RTMP推到CDN，进行下发。连接这一路的观众，不能参与连麦互动，达到了最佳直播效果。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;整个直播流程分为几个关键步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主播客户端，将本地采集的视频推送到CDN&lt;/li&gt;
&lt;li&gt;CDN对视频流进行缓存以及转发&lt;/li&gt;
&lt;li&gt;观众客户端，拉取CDN中缓存的视频流进行播放&lt;br&gt;&lt;img src=&quot;https://raw.githu
      
    
    </summary>
    
      <category term="科研" scheme="https://wonderxiao.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="视频" scheme="https://wonderxiao.github.io/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>汇编</title>
    <link href="https://wonderxiao.github.io/2017/10/18/%E6%B1%87%E7%BC%96/"/>
    <id>https://wonderxiao.github.io/2017/10/18/汇编/</id>
    <published>2017-10-17T16:30:03.000Z</published>
    <updated>2018-05-04T13:53:09.542Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>反汇编指令使用<br>gdb disas [function-name]<br>objdump -d/-D obj-name对整个程序进行反汇编<br>通过这个反汇编可以发现main函数并非一个程序的入口，而是__start函数</li></ul><p>函数调用时入栈的顺序是编译时确定的，函数调用之前需要入栈的主要是函数参数，而参数都是固定，可变参数只是用宏确定偏移量。<br>调用函数的代码放在代码段。入栈是以指令方式进行的，所以都是编译时确定了的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;反汇编指令使用&lt;br&gt;gdb disas [function-name]&lt;br&gt;objdump -d/-D obj-name对整
      
    
    </summary>
    
      <category term="linux" scheme="https://wonderxiao.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://wonderxiao.github.io/tags/linux/"/>
    
      <category term="汇编" scheme="https://wonderxiao.github.io/tags/%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>linux内存分配函数</title>
    <link href="https://wonderxiao.github.io/2017/10/17/linux%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%87%BD%E6%95%B0/"/>
    <id>https://wonderxiao.github.io/2017/10/17/linux内存分配函数/</id>
    <published>2017-10-16T16:30:03.000Z</published>
    <updated>2018-05-08T02:13:09.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="bzero-函数"><a href="#bzero-函数" class="headerlink" title="bzero()函数"></a>bzero()函数</h2><p>原型：extern void bzero(void *s, int n)<br>用法：#include<string.h><br>功能：置字符串s的前n个字节为零且包括’\0’<br>说明：bzero无返回值，推荐使用memset()代替bzero()函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </div><div class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    <span class="keyword">char</span> s[<span class="number">5</span>];</div><div class="line">    <span class="keyword">float</span> f;</div><div class="line">  &#125; tt;</div><div class="line">  <span class="keyword">char</span> s[<span class="number">20</span>];</div><div class="line">  bzero(&amp;tt,<span class="keyword">sizeof</span>(tt));</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></string.h></p><h2 id="memset-函数"><a href="#memset-函数" class="headerlink" title="memset()函数"></a>memset()函数</h2><p>原型：extern void <em>memset(void </em>buffer, int c, int count)<br>用法：#include<string.h><br>功能：将buffer所指向内存区域的前count个字节置成c<br>说明：返回指向buffer的指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </div><div class="line">  <span class="keyword">char</span> *s=<span class="string">"Golden Global View"</span>;</div><div class="line">  clrscr();</div><div class="line">  <span class="built_in">memset</span>(s,<span class="string">'G'</span>,<span class="number">6</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></string.h></p><h2 id="setmem-函数"><a href="#setmem-函数" class="headerlink" title="setmem()函数"></a>setmem()函数</h2><p>原型：extern void setmem(void *buf, unsigned int count, char ch)<br>功能：把buf所指内存区域前count个字节设置成字符ch<br>说明：返回指向buf的指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;syslib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </div><div class="line">  <span class="keyword">char</span> *s=<span class="string">"Golden Global View"</span>;</div><div class="line">  clrscr();</div><div class="line">  setmem(s,<span class="number">6</span>,<span class="string">'G'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><strong>在LINUX平台上是支持bzero的，但是其并不在ANSI C中定义，也就是不属于C的库函数</strong><br>在C/C++ code上<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> bzero(a, b)             memset(a, 0, b)</span></div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在初始化内存空间时，尽量使用memset()函数，由于其属于标准C的库函数，而各方面支持的都好。同时，其返回值是指向需分配的buffer的指针，能够进行很好的参数传递。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;bzero-函数&quot;&gt;&lt;a href=&quot;#bzero-函数&quot; class=&quot;headerlink&quot; title=&quot;bzero()函数&quot;&gt;&lt;/a&gt;bzero()函数&lt;/h2&gt;&lt;p&gt;原型：extern void bzero(void *s, int n)&lt;br&gt;用法：#
      
    
    </summary>
    
      <category term="linux" scheme="https://wonderxiao.github.io/categories/linux/"/>
    
    
      <category term="内存分配" scheme="https://wonderxiao.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>类型转换</title>
    <link href="https://wonderxiao.github.io/2017/10/17/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://wonderxiao.github.io/2017/10/17/类型转换/</id>
    <published>2017-10-16T16:28:19.000Z</published>
    <updated>2018-05-04T13:50:55.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于类型转换"><a href="#关于类型转换" class="headerlink" title="关于类型转换"></a>关于类型转换</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> p = <span class="number">0x12345678</span>;</div><div class="line"><span class="keyword">char</span> *t;</div><div class="line">t = (<span class="keyword">char</span> *)&amp;p;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"p:0x%x\n"</span>,&amp;p);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"q[0]:0x%x\n"</span>,q[<span class="number">0</span>]);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"&amp;q[0]:0x%x\n"</span>,&amp;q[<span class="number">0</span>]);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"q[1]:0x%x\n"</span>,q[<span class="number">1</span>]);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"&amp;q[1]:0x%x\n"</span>,&amp;q[<span class="number">1</span>]);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"q[2]:0x%x\n"</span>,q[<span class="number">2</span>]);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"&amp;q[2]:0x%x\n"</span>,&amp;q[<span class="number">2</span>]);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"q[3]:0x%x\n"</span>,q[<span class="number">3</span>]);</div><div class="line"><span class="built_in">printf</span>(<span class="string">"&amp;q[3]:0x%x\n"</span>,&amp;q[<span class="number">3</span>]);</div><div class="line"></div><div class="line">运行结果：</div><div class="line"></div><div class="line">p:<span class="number">0xffffcbc4</span></div><div class="line">q[<span class="number">0</span>]:<span class="number">0x78</span></div><div class="line">&amp;q[<span class="number">0</span>]:<span class="number">0xffffcbc4</span></div><div class="line">q[<span class="number">1</span>]:<span class="number">0x56</span></div><div class="line">&amp;q[<span class="number">1</span>]:<span class="number">0xffffcbc5</span></div><div class="line">q[<span class="number">2</span>]:<span class="number">0x34</span></div><div class="line">&amp;q[<span class="number">2</span>]:<span class="number">0xffffcbc6</span></div><div class="line">q[<span class="number">3</span>]:<span class="number">0x12</span></div><div class="line">&amp;q[<span class="number">3</span>]:<span class="number">0xffffcbc7</span></div></pre></td></tr></table></figure><ul><li><p>&amp;p本来是int *类型，强制转换为char *</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> *p = &amp;a;</div></pre></td></tr></table></figure></li><li><p>int *p表示（int *)p，即指向整型变量的指针变量</p></li><li>p对于a的首地址</li><li>p所对内存长度为sizeof(int)个字节</li></ul><p>对指针进行强制类型转换时并不改变指针的值，即对应的首地址，但其对应的内存长度会改变。许多编译器对指针类型要求严格，在传递指针时要进行强制类型转换。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> m = <span class="number">20</span>;</div><div class="line"><span class="keyword">float</span> t;</div><div class="line">t = (<span class="keyword">float</span>)m;</div></pre></td></tr></table></figure></p><p>此时的强制类型转换，会将m处存放的值转化为float型的变量赋给t里的内容。<br>再举一例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch1 = <span class="number">0x0A</span>; <span class="comment">// 假设ch1地址位于20H，即m[20H] = 0x0AH</span></div><div class="line"><span class="keyword">char</span>* p1 = &amp;ch1;</div><div class="line"><span class="keyword">char</span>** pp1 = &amp;p1;</div></pre></td></tr></table></figure></p><p>观察下表：</p><table><thead><tr><th style="text-align:center">variable</th><th style="text-align:center">addr</th><th style="text-align:center">value </th></tr></thead><tbody><tr><td style="text-align:center">ch1</td><td style="text-align:center">20</td><td style="text-align:center">0A   </td></tr><tr><td style="text-align:center">None</td><td style="text-align:center">21</td><td style="text-align:center">CC    </td></tr><tr><td style="text-align:center">p1</td><td style="text-align:center">22</td><td style="text-align:center">20  </td></tr><tr><td style="text-align:center">pp1</td><td style="text-align:center">23</td><td style="text-align:center">22    </td></tr></tbody></table><p>若内存空间可看成一个数组：char m[256]，则<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch1 = **pp1;</div></pre></td></tr></table></figure></p><p>因此，可理解成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch1 = m[m[pp1]]; <span class="comment">// 解二级指针引用</span></div></pre></td></tr></table></figure></p><p>同样地，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> ch2 = *p1;</div><div class="line">可理解成：</div><div class="line"><span class="keyword">char</span> ch2 = m[p1];<span class="comment">// 解指针引用</span></div></pre></td></tr></table></figure></p><p>在汇编层面，就是按上述叙述理解，比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">MOV EAX, [EDA + <span class="number">8</span>]</div><div class="line">CALL EAX</div></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当你想动态分配内存给二维数组，如矩阵、表等的时候，就可以使用(* *)这种二级指针进行操作了。简单地说，二级指针能够修改上一级的指针，就像一级指针能修改其指向的值。<br>同时，二级指针相对于一级指针来说，其减少了函数传参，如需传一个*offset来指示函数调用后的偏移量，而若传二级指针，则在函数调用后，指针就自动直接指向偏移后的地址了。<br>另一方面，二级指针，只是指向的变量换成指针了而已。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于类型转换&quot;&gt;&lt;a href=&quot;#关于类型转换&quot; class=&quot;headerlink&quot; title=&quot;关于类型转换&quot;&gt;&lt;/a&gt;关于类型转换&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
      <category term="内存管理" scheme="https://wonderxiao.github.io/categories/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="类型转换" scheme="https://wonderxiao.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>网络通信关键函数理解</title>
    <link href="https://wonderxiao.github.io/2017/10/17/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%85%B3%E9%94%AE%E5%87%BD%E6%95%B0%E7%90%86%E8%A7%A3/"/>
    <id>https://wonderxiao.github.io/2017/10/17/网络通信关键函数理解/</id>
    <published>2017-10-16T16:25:36.000Z</published>
    <updated>2018-05-08T02:10:35.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sockaddr-in"><a href="#sockaddr-in" class="headerlink" title="sockaddr_in"></a>sockaddr_in</h2><p>当我们调用bind()、connect()等函数时，都需传入一个struct sockaddr *类型指针，用来表明地址信息，即需对哪个IP、哪个端口进行bind或connect操作。这时，我们传给函数关于地址信息的参数会强制转换成sockaddr_in类型的形式，即struct sockaddr是通用的套接字地址形式。<br>在linux环境下，结构体struct sockaddr在/usr/include/linux/socket.h中定义，具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">sa_family_t</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></div><div class="line">        <span class="keyword">sa_family_t</span>     sa_family;    <span class="comment">/* address family, AF_xxx       */</span></div><div class="line">        <span class="keyword">char</span>            sa_data[<span class="number">14</span>];    <span class="comment">/* 14 bytes of protocol address */</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>sa_family是地址家族，一般以”AF_xxx”形式存在，通常为AF_INET，代表TCP/IP协议簇</li><li>sa_data是14字节协议地址<ul><li>4个字节的无符号整数（IP地址）</li><li>2个字节的无符号整数（端口号）</li></ul></li></ul><p>从sockaddr的定义中，无法确定IP地址和端口号在这14个字节地址空间中的存放位置。因此，进行参数传递时，还需知道这14个字节的空间是如何利用，即哪里放IP地址、哪里放端口号、哪里是空白。<br>于是，在此基础上，构造了sockaddr_in的结构体。<br>在linux环境下，结构体struct sockaddr_in在/usr/include/netinet/in.h中定义，具体如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Structure describing an Internet socket address. */</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    __SOCKADDR_COMMON (sin_family);         <span class="comment">/* Address family */</span></div><div class="line">    <span class="keyword">in_port_t</span> sin_port;                     <span class="comment">/* Port number. */</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>            <span class="comment">/* Internet address. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Pad to size of `struct sockaddr'. */</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="keyword">sizeof</span> (struct sockaddr) -</div><div class="line">                           __SOCKADDR_COMMON_SIZE -</div><div class="line">                           <span class="keyword">sizeof</span> (<span class="keyword">in_port_t</span>) -</div><div class="line">                           <span class="keyword">sizeof</span> (struct in_addr)];     </div><div class="line">                           <span class="comment">/* 字符数组sin_zero[8]的存在是为了保证结构体struct sockaddr_in的大小和结构体struct sockaddr的大小相等 */</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOCKADDR_COMMON(sa_prefix) \</span></div><div class="line">   <span class="keyword">sa_family_t</span> sa_prefix#<span class="meta">#family <span class="comment">/*此为整型变量占2字节，主要用于指明地址类型，取值为AF_UNIX|AF_INET|AF_INET6|AF_PACKET等*/</span></span></div></pre></td></tr></table></figure></p><ul><li>sin_family指代协议族，在socket编程中只能是AF_INET</li><li>sin_port存储端口号(使用网络字节顺序)</li><li>sin_addr存储IP地址，使用in_addr这个数据结构</li><li>sin_zero是为了让sockaddr与sockaddr_in两个数据结构保持大小相同而保留的空字节</li></ul><p>下面是struct sockaddr_in中用到两个数据类型，具体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Type to represent a port. */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">in_port_t</span>; </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>其实就是32位<span class="title">IP</span>地址</span></div><div class="line"><span class="class"><span class="title">struct</span> <span class="title">in_addr</span> &#123;</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><strong>s_addr按照网络字节顺序存储IP地址</strong></p><ul><li>struct sockaddr是通用的套接字地址形式</li><li>struct sockaddr_in是Internet下套接字的地址形式</li></ul><p>sockaddr_in和sockaddr长度均为16字节，是并列结构，指向sockadd_in结构的指针，也可指向sockaddr的结构体。也就是说，你使用sockaddr_in建立你所需要的信息，然后按照函数要求进行类型转换就可以了。<br>比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sockaddr_in mySock;</div><div class="line">bzero((<span class="keyword">char</span> *)&amp;mySock,<span class="keyword">sizeof</span>(mySock));</div><div class="line">mySock.sa_family = AF_INET;</div><div class="line">mySock.sin_port = htons(<span class="number">1234</span>);</div><div class="line">mySock.sin_addr.s_addr = inet_addr(<span class="string">"192.168.1.1"</span>);</div></pre></td></tr></table></figure></p><p>在一般构建网络通信过程中，需将sockaddr_in结构强制转换成sockaddr结构，再传入系统调用函数中。通常，BSD网络软件中包含了两个函数，用来在<strong>二进制地址格式和点分十进制字符串格式</strong>之间相互转换，但是这两个函数仅仅支持IPv4。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span> *cp);</div><div class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</div></pre></td></tr></table></figure></p><p>功能相似的两个函数同时支持IPv4和IPv6<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">char</span> *str, <span class="keyword">socklen_t</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">void</span> *addr)</span></span>;</div></pre></td></tr></table></figure></p><h2 id="通常用法"><a href="#通常用法" class="headerlink" title="通常用法"></a>通常用法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sockfd;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">my_addr</span>;</span></div><div class="line">sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</div><div class="line">my_addr.sin_family = AF_INET;</div><div class="line">my_addr.sin_port = htons(MYPORT);</div><div class="line">my_addr.sin_addr.s_addr = inet_addr(<span class="string">"192.168.1.1"</span>);</div><div class="line">bzero(&amp;(my_addr.sin_zero), <span class="number">8</span>));</div><div class="line"><span class="comment">//memset(&amp;(my_addr.sin_zero), 0, 8);</span></div><div class="line">bind(sockfd, (struct sockaddr *)&amp;my_addr, <span class="keyword">sizeof</span>(struct sockaddr));</div></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在进行网络编程时，常常使用的函数如bind()、connect()函数都已定义好。在这些函数传参过程中，需按照参数的标准类型进行传递。而定义struct sockaddr时，往往不能确定网络地址和端口号在内存中的具体存储。于是，使用struct sockaddr_in将存储地址定义清楚。在此之后，由于其结构空间一样，可直接进行类型转换，就如(int <em>)转换成(float </em>)一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sockaddr-in&quot;&gt;&lt;a href=&quot;#sockaddr-in&quot; class=&quot;headerlink&quot; title=&quot;sockaddr_in&quot;&gt;&lt;/a&gt;sockaddr_in&lt;/h2&gt;&lt;p&gt;当我们调用bind()、connect()等函数时，都需传入一个st
      
    
    </summary>
    
      <category term="linux" scheme="https://wonderxiao.github.io/categories/linux/"/>
    
    
      <category term="socket编程" scheme="https://wonderxiao.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://wonderxiao.github.io/2017/10/16/hello-world/"/>
    <id>https://wonderxiao.github.io/2017/10/16/hello-world/</id>
    <published>2017-10-16T08:36:21.804Z</published>
    <updated>2017-10-11T07:51:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GitHub上搭建博客&amp;增加相册功能</title>
    <link href="https://wonderxiao.github.io/2017/10/13/GitHub%E4%B8%8A%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E5%A2%9E%E5%8A%A0%E7%9B%B8%E5%86%8C%E5%8A%9F%E8%83%BD/"/>
    <id>https://wonderxiao.github.io/2017/10/13/GitHub上搭建博客-增加相册功能/</id>
    <published>2017-10-12T19:34:26.000Z</published>
    <updated>2018-05-08T02:13:32.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>在github上成功搭建Hexo博客</li><li>实现在博客上浏览图片，添加图片功能</li></ul><p>最终效果:<a href="https://wonderxiao.github.io/">https://wonderxiao.github.io/</a></p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ul><li>使用主题：<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="external">hexo-theme-yilia</a>来搭建Hexo博客</li><li>使用<a href="http://lawlite.me/photos/" target="_blank" rel="external">lawlite</a>来增加相册功能，其中必须的样式文件点击<a href="https://github.com/wonderxiao/BlogPicture/tree/master/four" target="_blank" rel="external">必需文件</a><br>在photos中包含四个文件</li><li>index.ejs</li><li>ins.css</li><li>ins.js</li><li>lazyload.min.js</li></ul><h1 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h1><ul><li>申请github账号</li><li>windows系统下使用腾讯管家安装git</li><li>安装<a href="https://npm.taobao.org/mirrors/node/v8.6.0/node-v8.6.0-x64.msi" target="_blank" rel="external">nodejs</a></li></ul><h2 id="验证软件安装成功"><a href="#验证软件安装成功" class="headerlink" title="验证软件安装成功"></a>验证软件安装成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git --version <span class="comment">#git@2.13.0</span></div><div class="line">$ node -v       <span class="comment">#node@8.6.0</span></div><div class="line">$ npm -v        <span class="comment">#npm@5.3.0</span></div></pre></td></tr></table></figure><h2 id="git与github互联实现远程控制"><a href="#git与github互联实现远程控制" class="headerlink" title="git与github互联实现远程控制"></a>git与github互联实现远程控制</h2><ul><li>创建repository，新建一个版本库<br>创建的版本库名字设置注意事项如图中所示，即xxx/xxx.github.io</li></ul><p><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-12_%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="创建版本库"></p><ul><li>配置SSH key<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/.ssh <span class="comment">#查看本机是否已存在ssh密钥</span></div></pre></td></tr></table></figure></li></ul><p>若提示：No such file or directory 说明你是第一次使用git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址"</span></div></pre></td></tr></table></figure><p>一直回车，若需yes请输入，这是给权限，最终会生成文件在用户目录下，找到.ssh/id_rsa.pub文件，复制文件里的内容。  </p><ul><li>打开setting，建立本地系统的git bash与github连接权限，具体设置如下图所示：<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-12_%E5%88%9B%E5%BB%BA%E8%BF%9E%E6%8E%A5.png" alt="创建连接 "></li></ul><h2 id="测试是否成功"><a href="#测试是否成功" class="headerlink" title="测试是否成功"></a>测试是否成功</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ssh git@github.com</div></pre></td></tr></table></figure><p>若如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：  </p><blockquote><p>Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access.  </p></blockquote><h2 id="使用Hexo博客"><a href="#使用Hexo博客" class="headerlink" title="使用Hexo博客"></a>使用Hexo博客</h2><p>Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>github page存放的都是静态文件，博客不仅存放文章内容，还存放文章列表、分类、标签、分类等动态文件。若每次写文章都去更新博文目录及其相关链接，那会很复杂。故每次写完博客，通过使用hexo来批量处理相关页面的生成，将有改动的内容更新到github上。 </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo</div></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在电脑上某处新建hexo的文件夹，此文件夹为你存放，如F:\workBlog\hexo，然后使用hexo命令进行初始化。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> /f/workBlog/hexo/</div><div class="line">$ hexo init</div></pre></td></tr></table></figure></p><p>这样，hexo会自动下载hexo所需文件，如node_modules等。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean <span class="comment">#清除之前产生的内容，如hexo g产生的</span></div><div class="line">$ hexo generate <span class="comment">#生成</span></div><div class="line">$ hexo server <span class="comment">#启动服务</span></div></pre></td></tr></table></figure></p><p>hexo server是开启本地预览服务，打开浏览器访问<a href="http://localhost:4000，即可看到加载的hexo博客" target="_blank" rel="external">http://localhost:4000，即可看到加载的hexo博客</a></p><h2 id="此阶段遇到的问题"><a href="#此阶段遇到的问题" class="headerlink" title="此阶段遇到的问题"></a>此阶段遇到的问题</h2><p>本地浏览器加载时出现一直转圈，不能访问<br>此处一般为端口占用，解决方法: </p><ul><li>查看电脑中占用端口4000的进程，关闭即可  </li><li>打开hexo文件夹下_config.yml,将配置中端口port改成未占用的端口即可 </li></ul><hr><h2 id="上传到github"><a href="#上传到github" class="headerlink" title="上传到github"></a>上传到github</h2><p>若一切配置到之后，使用hexo deploy发布即可。<br>但需满足:</p><ul><li>ssh key配置正确</li><li>配置hexo目录下_config.yml文件    </li></ul><p>在_config.yml最后面添加:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  <span class="built_in">type</span>: git</div><div class="line">  repository: git@github.com:xxx/xxx.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p><p>在此之后，一般出现：</p><blockquote><p>Deployer not found: github 或者 Deployer not found: git  </p></blockquote><p>这是需要安装插件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p><p>之后，进行发布博客后，点击所有文章会出现模块缺失<br>解决方法：  </p><ul><li>node版本升级</li><li>npm i hexo-generator-json-content –save</li><li>在hexo文件下的_config.yml下添加：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">jsonContent:</div><div class="line">  meta: <span class="literal">false</span></div><div class="line">  pages: <span class="literal">false</span></div><div class="line">  posts:</div><div class="line">    title: <span class="literal">true</span></div><div class="line">    date: <span class="literal">true</span></div><div class="line">    path: <span class="literal">true</span></div><div class="line">    text: <span class="literal">false</span></div><div class="line">    raw: <span class="literal">false</span></div><div class="line">    content: <span class="literal">false</span></div><div class="line">    slug: <span class="literal">false</span></div><div class="line">    updated: <span class="literal">false</span></div><div class="line">    comments: <span class="literal">false</span></div><div class="line">    link: <span class="literal">false</span></div><div class="line">    permalink: <span class="literal">false</span></div><div class="line">    excerpt: <span class="literal">false</span></div><div class="line">    categories: <span class="literal">false</span></div><div class="line">    tags: <span class="literal">true</span></div></pre></td></tr></table></figure></li></ul><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></div><div class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></div><div class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></div><div class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></div><div class="line">hexo deploy <span class="comment">#部署到GitHub</span></div><div class="line">hexo <span class="built_in">help</span>  <span class="comment"># 查看帮助</span></div><div class="line">hexo version  <span class="comment">#查看Hexo的版本</span></div></pre></td></tr></table></figure><p>缩写：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">hexo n == hexo new</div><div class="line">hexo g == hexo generate</div><div class="line">hexo s == hexo server</div><div class="line">hexo d == hexo deploy</div></pre></td></tr></table></figure></p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">'my-first-blog'</span></div></pre></td></tr></table></figure><p>这时我们新建了my-first-blog.md文件，一般完整格式如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">title: postName <span class="comment">#文章页面上的显示名称，一般是中文  </span></div><div class="line">date: 2013-12-02 15:30:16 <span class="comment">#文章生成时间，一般不改，当然也可以任意修改  </span></div><div class="line">categories: 默认分类 <span class="comment">#分类  </span></div><div class="line">tags: [tag1,tag2,tag3] <span class="comment">#文章标签，可空，多标签请用格式，注意:后面有个空格  </span></div><div class="line">description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面</div><div class="line">---</div><div class="line">以下是正文</div></pre></td></tr></table></figure></p><h2 id="添加相册"><a href="#添加相册" class="headerlink" title="添加相册"></a>添加相册</h2><ul><li>github<br>建立一个用于存储相册的版本库，这里建立BlogPicture</li><li>和hexo同目录下，将github下新建的BlogPicture克隆到本地文件夹下</li><li>在BlogPicture下新建photos，将样式文件放在photos文件夹下，样式文件放在github上： <a href="https://github.com/wonderxiao/BlogPicture/tree/master/four" target="_blank" rel="external">https://github.com/wonderxiao/BlogPicture/tree/master/four</a><br>修改ins.js文件，主要是更改render函数</li><li>其中url对应你放在github上图片的地址，主要是更改src和minSrc</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">res</span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> ulTmpl = <span class="string">""</span>;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>, len2 = res.list.length; j &lt; len2; j++) &#123;</div><div class="line">          <span class="keyword">var</span> data = res.list[j].arr;</div><div class="line">          <span class="keyword">var</span> liTmpl = <span class="string">""</span>;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = data.link.length; i &lt; len; i++) &#123;</div><div class="line">            <span class="keyword">var</span> minSrc = <span class="string">'https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/min_photos/'</span> + data.link[i];</div><div class="line">  </div><div class="line">          <span class="keyword">var</span> src = <span class="string">'https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/'</span> + data.link[i];</div><div class="line">          </div><div class="line">          <span class="keyword">var</span> type = data.type[i];</div><div class="line">          <span class="keyword">var</span> target = src + (type === <span class="string">'video'</span> ? <span class="string">'.mp4'</span> : <span class="string">'.jpg'</span>);</div><div class="line">          src += <span class="string">''</span>;</div><div class="line"></div><div class="line">          liTmpl += <span class="string">'&lt;figure class="thumb" itemprop="associatedMedia" itemscope="" itemtype="http://schema.org/ImageObject"&gt;\</span></div><div class="line"><span class="string">                &lt;a href="'</span> + src + <span class="string">'" itemprop="contentUrl" data-size="1080x1080" data-type="'</span> + type + <span class="string">'" data-target="'</span> + src + <span class="string">'"&gt;\</span></div><div class="line"><span class="string">                  &lt;img class="reward-img" data-type="'</span> + type + <span class="string">'" data-src="'</span> + minSrc + <span class="string">'" src="/assets/img/empty.png" itemprop="thumbnail" onload="lzld(this)"&gt;\</span></div><div class="line"><span class="string">                &lt;/a&gt;\</span></div><div class="line"><span class="string">                &lt;figcaption style="display:none" itemprop="caption description"&gt;'</span> + data.text[i] + <span class="string">'&lt;/figcaption&gt;\</span></div><div class="line"><span class="string">            &lt;/figure&gt;'</span>;</div><div class="line">        &#125;</div><div class="line">        ulTmpl = ulTmpl + <span class="string">'&lt;section class="archives album"&gt;&lt;h1 class="year"&gt;'</span> + data.year + <span class="string">'年&lt;em&gt;'</span> + data.month + <span class="string">'月&lt;/em&gt;&lt;/h1&gt;\</span></div><div class="line"><span class="string">        &lt;ul class="img-box-ul"&gt;'</span> + liTmpl + <span class="string">'&lt;/ul&gt;\</span></div><div class="line"><span class="string">        &lt;/section&gt;'</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'.instagram'</span>).innerHTML = <span class="string">'&lt;div class="photos" itemscope="" itemtype="http://schema.org/ImageGallery"&gt;'</span> + ulTmpl + <span class="string">'&lt;/div&gt;'</span>;</div><div class="line">        createVideoIncon();</div><div class="line">        _view2.default.init();</div><div class="line">        &#125;;</div></pre></td></tr></table></figure><ul><li><a href="https://github.com/wonderxiao/BlogPicture/tree/master/photos" target="_blank" rel="external">python脚本文件</a><br>下载python脚本文件按照我的这种目录进行构建<br>+-<br>BlogPicture<br>&nbsp;&nbsp;&nbsp;&nbsp;+- hexo<br>&nbsp;&nbsp;&nbsp;&nbsp;+- BlogPicture<br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; +-four ##四个样式文件<br>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; +-photos ##存放相册中的相片与python文件</li></ul><h2 id="相片文件命名格式——json转换"><a href="#相片文件命名格式——json转换" class="headerlink" title="相片文件命名格式——json转换"></a>相片文件命名格式——json转换</h2><ul><li>2017-10-12_时钟.png</li><li>最前面的是日期，然后用_分割</li><li>后面信息为描述图片信息  </li></ul><p><strong>注意data.json存储位置及tool.py中src_dir和des_dir路径信息</strong>  </p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>若缩略图不显示，下载<a href="https://github.com/wonderxiao/wonderxiao.github.io/blob/master/assets/img/empty.png" target="_blank" rel="external">empty.png文件</a>再进行重新上传文件即可。</p><p>##效果图：</p><p><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-12_%E6%95%88%E6%9E%9C%E5%9B%BE.png" alt="效果图"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;在github上成功搭建Hexo博客&lt;/li&gt;
&lt;li&gt;实现在博客上浏览图片，添加图片功能&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最终效果
      
    
    </summary>
    
      <category term="博客" scheme="https://wonderxiao.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="https://wonderxiao.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Linux内核学习</title>
    <link href="https://wonderxiao.github.io/2017/10/12/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0/"/>
    <id>https://wonderxiao.github.io/2017/10/12/Linux内核学习/</id>
    <published>2017-10-12T09:08:24.000Z</published>
    <updated>2018-05-08T02:12:53.488Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要目的是学习并归纳Linux操作系统中内核的几个基本重要知识</p><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><ul><li>一个进程在地址空间中执行一个单独的指令序列  </li></ul><p><strong>地址空间</strong>是允许进程引用的内存空间的集合，操作系统允许具有多个执行流的进程，即在相同的地址空间可执行多个指令序列。<br>进程能并发活动，竞争的系统资源主要是CPU<br>区分程序和进程：</p><ul><li>几个进程能并发执行同一个程序，同时，同一进程能顺序执行多个程序</li></ul><p>现在的CPU处理器一般都是多核CPU，可通过任务管理器查看。而在单处理器系统上，只有一个进程能占用CPU。因此，在某时刻，只能有一个执行流。<br>CPU有多少个，就有多少个进程可同时执行。选择哪个进程执行由操作系统的调度程序决定，进程分为抢占式进程和非抢占式进程。<br>对于<em>抢占式进程</em>，只有进程自愿放弃CPU，调度程序才会被调用；<br>对于<em>非抢占式进程</em>，如多用户系统中的进程调度，操作系统记录下每个进程占优的CPU时间，并周期性地激活调度程序。</p><hr><p>为了标识一个特定的文件，进程使用路径名，路径名由斜杠及一列指向文件的目录名交替组成。若路径名第一个字符是斜杠那么该路径就为绝对路径，因为其起点是根目录。若第一项是目录名或文件名，那么路径就是相对路径，因为其起点是进程的当前目录。</p><hr><h2 id="Linux文件与目录"><a href="#Linux文件与目录" class="headerlink" title="Linux文件与目录"></a>Linux文件与目录</h2><p>操作系统为了解决信息能独立于进程之外被长期存储，而引入了文件。</p><ul><li>文件作为进程创建信息的逻辑单元，可被多个进程并发使用<br>在Unix系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等I/O操作设计了一组通用的API，使他们被处理时均可统一使用字节流。</li><li>Lniux系统中除进程外的一切都是文件，为了便于文件管理而引入目录，这使Linux文件系统形成了一个层级结构的目录树。</li></ul><p><strong>Linux系统顶层目录结构</strong><br> /              根目录<br>├── bin     存放用户二进制文件<br>├── boot    存放内核引导配置文件<br>├── dev     存放设备文件<br>├── etc     存放系统配置文件<br>├── home    用户主目录<br>├── lib     动态共享库<br>├── lost+found     文件系统恢复时的恢复文件<br>├── media   可卸载存储介质挂载点<br>├── mnt     文件系统临时挂载点<br>├── opt     附加的应用程序包<br>├── proc    系统内存的映射目录，提供内核与进程信息<br>├── root    root 用户主目录<br>├── sbin    存放系统二进制文件<br>├── srv     存放服务相关数据<br>├── sys     sys 虚拟文件系统挂载点<br>├── tmp     存放临时文件<br>├── usr     存放用户应用程序<br>└── var     存放邮件、系统日志等变化文件</p><ul><li>Linux系统并不区分文件和目录，目录是记录其他文件名的文件</li><li>Linux将设备当做文件处理</li></ul><p><strong>打开并读取设备文件</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> fd; </div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">ie</span>;</span> </div><div class="line">fd = open(<span class="string">"/dev/input/event3"</span>, O_RDONLY); </div><div class="line">read(fd, &amp;ie, <span class="keyword">sizeof</span>(struct input_event)); </div><div class="line"><span class="built_in">printf</span>(<span class="string">"type = %d  code = %d  value = %d\n"</span>, </div><div class="line"> ie.type, ie.code, ie.value); </div><div class="line">close(fd);</div></pre></td></tr></table></figure></p><p>其展示了如何打开设备文件event3并读取文件内容，文件event3表示一直输入设备，其可能是鼠标或键盘，通过查看 /proc/bus/input/devices 可知 event3 对应设备的类型。设备文件 /dev/input/event3 使用 read() 以字符流的方式被读取。结构体 input_event 被定义在内核头文件 linux/input.h 中。</p><ul><li>文件都有文件名和数据，在Linux上被分成两部分：用户数据与元数据</li><li>用户数据：文件数据块（data block)，数据块是记录文件内容的地方</li><li>元数据：文件的附加属性，即文件大小、创建时间及所有者等信息。</li></ul><p>在Linux中，元数据中的inode号为索引节点号，是文件的唯一标识。而文件名是为了方便人们记忆和使用，系统或程序是通过inode号来寻找正确的文件数据块。</p><ul><li>查看inode号使用stat或ls -i命令</li></ul><h2 id="硬链接-amp-软链接"><a href="#硬链接-amp-软链接" class="headerlink" title="硬链接&amp;软链接"></a>硬链接&amp;软链接</h2><p>链接不仅解决了Linux系统文件的共享使用，而且带来了隐藏文件路径、增加权限安全及节省存储等好处。</p><ul><li><p>硬链接：一个inode号对应多个文件名<br>文件A是文件B的硬链接，则A的目录项中的索引inode节点号与B的目录项中的inode节点相同，即同一个inode节点对应不同的文件名，两个文件名指向同一文件，A和B对于文件系统来说是完全等同的。</p></li><li><p>特点</p><blockquote><p>文件有相同的 inode 及 data block<br>只能对已存在的文件进行创建<br>不能交叉文件系统进行硬链接的创建<br>不能对目录进行创建，只可对文件创建<br>删除一个硬链接文件并不影响其他有相同 inode 号的文件</p></blockquote></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ touch <span class="built_in">test</span></div><div class="line">$ <span class="built_in">echo</span> <span class="string">"This is a test."</span> &gt; <span class="built_in">test</span></div><div class="line">$ cat <span class="built_in">test</span> </div><div class="line">This is a <span class="built_in">test</span>.</div><div class="line">$ ln <span class="built_in">test</span> filetxt</div><div class="line">$ ls -li</div><div class="line">total 8</div><div class="line">809185 -rw-rw-r-- 2 wonderxiao wonderxiao 16 10月 13 20:42 filetxt</div><div class="line">809185 -rw-rw-r-- 2 wonderxiao wonderxiao 16 10月 13 20:42 <span class="built_in">test</span></div></pre></td></tr></table></figure><p>其中，809185是文件的inode值，你可简单将文件看作C语言的指针，它指向物理硬盘的一个区块。事实上，文件系统会维护一个引用计数，只要有文件指向这个区块，它就不会从硬盘上消失。</p><p>inode 是随着文件的存在而存在，因此只有当文件存在时才可创建硬链接，即当 inode 存在且链接计数器不为 0 时。</p><p>若修改刚才创建的filetxt文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> <span class="string">"New one"</span> &gt;&gt; filetxt                  </div><div class="line">$ cat <span class="built_in">test</span> </div><div class="line">This is a <span class="built_in">test</span>.</div><div class="line">New one</div></pre></td></tr></table></figure><h3 id="可看到，这两个就如同一个文件一样，inode值一样，都指向同一个区块。"><a href="#可看到，这两个就如同一个文件一样，inode值一样，都指向同一个区块。" class="headerlink" title="可看到，这两个就如同一个文件一样，inode值一样，都指向同一个区块。"></a><em>可看到，这两个就如同一个文件一样，inode值一样，都指向同一个区块。</em></h3><h2 id="软链接——符号链接"><a href="#软链接——符号链接" class="headerlink" title="软链接——符号链接"></a>软链接——符号链接</h2><p>文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块,因此软链接的创建与使用没有类似硬链接的诸多限制。</p><ul><li>特点<blockquote><p>软链接有自己的文件属性及权限等<br>可对不存在的文件或目录创建软链接<br>软链接可交叉文件系统<br>软链接可对文件或目录创建<br>创建软链接时，链接计数 i_nlink 不会增加<br>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接</p></blockquote></li></ul><h2 id="链接的访问"><a href="#链接的访问" class="headerlink" title="链接的访问"></a>链接的访问</h2><p><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-13_%E9%93%BE%E6%8E%A5%E7%9A%84%E8%AE%BF%E9%97%AE.png" alt="链接的访问"><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ ln -s filetxt softtxt</div><div class="line">$ ls -li</div><div class="line">total 8</div><div class="line">809185 -rw-rw-r-- 2 wonderxiao wonderxiao 24 10月 13 21:11 filetxt</div><div class="line">809068 lrwxrwxrwx 1 wonderxiao wonderxiao  7 10月 13 21:14 softtxt -&gt; filetxt</div><div class="line">809185 -rw-rw-r-- 2 wonderxiao wonderxiao 24 10月 13 21:11 <span class="built_in">test</span></div></pre></td></tr></table></figure></p><p>这个软链接的inode值不一样了，且文件属性为1，说明刚才创建的软链接文件根本不是同一类型。</p><p>若删除filetxt文件，然后输出软硬链接文件内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ rm filetxt</div><div class="line">$ cat <span class="built_in">test</span></div><div class="line">This is a <span class="built_in">test</span>.</div><div class="line">New one</div></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ cat softtxt</div><div class="line">cat: softtxt: No such file or directory</div></pre></td></tr></table></figure><p>之前硬链接没有任何影响，这是由于其inode所指向的区块有一个硬链接在指向它，所以此区块仍然有效，可继续访问。而软链接的inode所指向的内容实际上保存的是一个绝对路径，当用户访问这个文件时，即访问的是这个文件路径所在的文件。此时，这个文件已被删除，所以找不到它。</p><ul><li>软链接：保存其代表的绝对路径，是另外一个文件，在硬盘上有独立的块，访问时会替换自身路径。</li><li>硬链接：代表的是文件的副本<h2 id="Linux-VFS"><a href="#Linux-VFS" class="headerlink" title="Linux VFS"></a>Linux VFS</h2>Linux有极其丰富的文件系统，可分为：</li><li>网络文件系统，如nfs、cifs等</li><li>磁盘文件系统，如ext4、ext3等</li><li>特殊文件系统，如proc、sysfs、ramfs、tmpfs等</li></ul><p>这些文件系统系统在Linux下共存的基础是Linux VFS(Virtual File System)，VFS作为一个通用的文件系统，抽象定义了文件系统的四个基本概念：</p><ul><li>文件</li><li>目录项</li><li>索引节点</li><li>挂载点</li></ul><p>其在内核中，为用户空间层的文件系统提供了相关接口，即VFS实现了open()、read()等系统调用的函数，这就真正实现：在Linux系统中，除进程外一切都是文件。</p><h2 id="VFS在系统中架构"><a href="#VFS在系统中架构" class="headerlink" title="VFS在系统中架构"></a>VFS在系统中架构</h2><p><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-13_VFS%E5%9C%A8%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="VFS在系统架构"></p><p>VFS存在四个基本对象：</p><ul><li>超级块对象(superblock object)<br>一个已安装的文件系统</li><li>索引节点对象(inode object)<br>一个文件</li><li>目录项对象(dentry object)<br>一个目录项，如设备文件event3在路径/dev/input/event3中，存在四个目录项对象：/、dev/、input/及event3。</li><li>文件对象(file object)<br>代表进程打开的文件</li></ul><p>这四个对象与进程及磁盘文件间的关系如下图：<br><img src="https://raw.githubusercontent.com/wonderxiao/BlogPicture/master/photos/2017-10-13_VFS%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E5%A4%84%E7%90%86.png" alt="对象与进程及磁盘文件间的关系"></p><p>其中，d_inode为硬链接，是文件路径的快速解析。同时，Linux VFS设计了目录项缓存dcache。</p><p>在Linux中，索引节点结构存在于系统内存及磁盘中，其可分为VFS inode与实际文件系统的inode。VFS inode是作为实际文件系统中inode的抽象。</p><h2 id="VFS中inode与inode-operations结构体"><a href="#VFS中inode与inode-operations结构体" class="headerlink" title="VFS中inode与inode_operations结构体"></a>VFS中inode与inode_operations结构体</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span> </div><div class="line">    ... </div><div class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>   *<span class="title">i_op</span>;</span> <span class="comment">// 索引节点操作</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span>           i_ino;      <span class="comment">// 索引节点号</span></div><div class="line">    <span class="keyword">atomic_t</span>                i_count;    <span class="comment">// 引用计数器</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>            i_nlink;    <span class="comment">// 硬链接数目</span></div><div class="line">    ... </div><div class="line"> &#125; </div><div class="line"></div><div class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> &#123;</span> </div><div class="line">    ... </div><div class="line">    <span class="keyword">int</span> (*create) (struct inode *,struct dentry *,<span class="keyword">int</span>, struct nameidata *); </div><div class="line">    <span class="keyword">int</span> (*link) (struct dentry *,struct inode *,struct dentry *); </div><div class="line">    <span class="keyword">int</span> (*unlink) (struct inode *,struct dentry *); </div><div class="line">    <span class="keyword">int</span> (*symlink) (struct inode *,struct dentry *,<span class="keyword">const</span> <span class="keyword">char</span> *); </div><div class="line">    <span class="keyword">int</span> (*mkdir) (struct inode *,struct dentry *,<span class="keyword">int</span>); </div><div class="line">    <span class="keyword">int</span> (*rmdir) (struct inode *,struct dentry *); </div><div class="line">    ... </div><div class="line"> &#125;</div></pre></td></tr></table></figure><p>每个文件存在两个计数器：</p><ul><li>i_count:引用计数,用于跟踪文件被访问的数量,或者说 i_count 跟踪文件在内存中的情况</li><li>i_nlink:硬链接计数,使用 ls -l 等命令查看到的文件硬链接数,即是磁盘计数器。当文件被删除时，则 i_nlink 先被设置成 0。</li></ul><p>文件的这两个计数器使得 Linux 系统升级或程序更新变的容易。系统或程序可在不关闭的情况下（即文件 i_count 不为 0），将新文件以同样的文件名进行替换，新文件有自己的 inode 及 data block，旧文件会在相关进程关闭后被完整的删除。</p><h2 id="文件系统-ext4-中的-inode"><a href="#文件系统-ext4-中的-inode" class="headerlink" title="文件系统 ext4 中的 inode"></a>文件系统 ext4 中的 inode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ext4_inode</span> &#123;</span> </div><div class="line">    ... </div><div class="line">    __le32  i_atime;        <span class="comment">// 文件内容最后一次访问时间</span></div><div class="line">    __le32  i_ctime;        <span class="comment">// inode 修改时间</span></div><div class="line">    __le32  i_mtime;        <span class="comment">// 文件内容最后一次修改时间</span></div><div class="line">    __le16  i_links_count;  <span class="comment">// 硬链接计数</span></div><div class="line">    __le32  i_blocks_lo;    <span class="comment">// Block 计数</span></div><div class="line">    __le32  i_block[EXT4_N_BLOCKS];  <span class="comment">// 指向具体的 block </span></div><div class="line">    ... </div><div class="line"> &#125;;</div></pre></td></tr></table></figure><p>其中三个时间的定义可对应与命令 stat 中查看到三个时间。i_links_count 不仅用于文件的硬链接计数，也用于目录的子目录数跟踪（目录并不显示硬链接数，命令 ls -ld 查看到的是子目录数）。由于文件系统 ext3 对 i_links_count 有限制，其最大数为：32000（该限制在 ext4 中被取消）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文描述了 Linux 系统中文件与目录被引入的原因及 Linux 处理文件的方式，然后我们通过区分硬链接与软链接的不同，了解 Linux 中的索引节点的相关知识，并以此引出了 inode 的结构体。索引节点结构体存在在于 Linux VFS 以及实际文件系统中，VFS 作为通用文件模型是 Linux 中“一切皆是文件”实现的基础。文章并未深入 Linux VFS，也没涉及实际文件系统的实现，文章只是从 inode 了解 Linux 的文件系统的相关内容。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要目的是学习并归纳Linux操作系统中内核的几个基本重要知识&lt;/p&gt;
&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一个进程在地址空间中执行一个单独的指令序列  
      
    
    </summary>
    
      <category term="linux" scheme="https://wonderxiao.github.io/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://wonderxiao.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>bit、Byte、bps、Bps、pps、Gbps的单位详细说明及换算</title>
    <link href="https://wonderxiao.github.io/2017/06/23/%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2/"/>
    <id>https://wonderxiao.github.io/2017/06/23/单位转换/</id>
    <published>2017-06-22T16:25:36.000Z</published>
    <updated>2018-05-04T13:52:46.297Z</updated>
    
    <content type="html"><![CDATA[<p><strong>bit</strong></p><ul><li>电脑记忆体中最小的单位，在二进位电脑系统中，每一bit 可以代表0 或 1 的数位信号。  </li></ul><p><strong>Byte</strong></p><ul><li>字节单位，一般表示存储介质大小的单位，一个B（常用大写的B来表示Byte）可代表一个字元(A~Z)、数字(0~9)、符号(,.?!%&amp;+-*/)，但中文字需要2个Byte。<br>1 Byte = 8 bits<br>1 KB = 1024 Bytes<br>1 MB = 1024 KB<br>1 GB = 1024 MB  </li></ul><p>注意：在计算存储介质大小时，需要用2的n次方来换算（1KB = 2^10 Bytes）。</p><p><strong>bps</strong>  </p><ul><li>“bits per second”常用于表示数据机及网络通讯的传输速率。  </li></ul><p>例如GigabitEthernet端口：<br>5 minute input rate 38410000 bits/sec<br>6344 packets/sec<br>382410000 bits/sec = 382.41Mbps<br>所以常说的快速以太网能达到百兆传输，其实实际传输文件大小只有10MB = 100Mb  </p><p>注意：在计算传输速率时，直接用1000来换算（1 Mb = 1000 Kb = 1000,000 bit）。</p><p><strong>Bps</strong>  </p><ul><li>“Byte per second”电脑一般都以Bps显示速度，但有时会跟传输速率混淆，例如ADSL宣称的带宽为1Mbps ，但在实际应用中，下载速度没有1MB ，只有1Mbps/8 = 128kBps。也就是说与传输速度有关的b一般指的是bit，与容量有关的B一般指的是Byte。 </li></ul><p><strong>pps</strong> - 包转发率</p><ul><li><p>包转发率标志了交换机转发数据包能力的大小。单位一般位pps（包每秒），一般交换机的包转发率在几十Kpps到几百Mpps不等。包转发速率是指交换机每秒可以转发多少百万个数据包（Mpps），即交换机能同时转发的数据包的数量。</p></li><li><p>包转发率以数据包为单位体现了交换机的交换能力。</p></li></ul><p><strong>Gbps</strong> - 背板带宽  </p><ul><li>交换机的背板带宽，是交换机接口处理器或接口卡和数据总线间所能吞吐的最大数据量。背板带宽标志了交换机总的数据交换能力，单位为Gbps，也叫交换带宽，一般的交换机的背板带宽从几Gbps到上百Gbps不等。一台交换机的背板带宽越高，所能处理数据的能力就越强，但同时设计成本也会越高。</li></ul><p>从以下两个方面可以判断一台交换机背板带宽的可用性：  </p><ul><li>==所有端口容量×端口数量×2==小于等于背板带宽，可实现全双工无阻塞交换，证明交换机具有发挥最大数据交换性能的条件。</li><li>满配置吞吐量(Mpps) = 满配置GE端口数×1.488Mpps，其中1个千兆端口在包长为64字节时的理论吞吐量为1.488Mpps。</li></ul><p><strong>GE端口理论吞吐量</strong>-1.488Mpps  </p><ul><li><p>以太网传输最小包长是64字节。包转发线速的衡量标准是以单位时间内发送64byte的数据包（最小包）的个数作为计算基准的。  </p></li><li><p>对于千兆以太网来说，计算方法如下：<br>1000Mbps/((64B+8B+12B)×8bit)=1.488095pps</p></li></ul><p>说明：当以太网帧为64Byte时，需考虑8Byte的前导符和12Byte的帧间隙的固定开销。  </p><p>在以太网中，每个帧头都要加上了8个字节的前导符，前导符的作用在于告诉监听设备数据将要到来。然后，以太网中的每个帧之间都要有帧间隙，即每发完一个帧，之后要等待一段时间再发另外一个帧，在以太网标准中规定最小是12个字节，然而帧间隙在实际应用中有可能会比12个字节要大，在这里我用了最小值。<br>每个帧都要有20个字节的固定开销。（另外这20字节的信息是不能通过抓包软件抓下来的）  </p><p>因此一个全双工线速的千兆以太网端口在转发64Byte包时的包转发率为1.488Mpps。</p><p>以下是常用以太网端口的包转发率：  </p><ul><li>万兆以太网：14.88Mpps  </li><li>千兆以太网：1.488Mpps</li><li>百兆以太网：0.1488Mpps  </li></ul><p>Router 的 kbits 单位等同于 kbps</p><p><strong>位</strong> </p><ul><li>“位(bit)”是电子计算机中最小的数据单位。每一位的状态只能是0或1。 </li></ul><p><strong>字节</strong></p><ul><li>8个二进制位构成1个”字节(Byte)”，它是存储空间的基本计量单位。</li></ul><p>1个字节可以储存1个英文字母或者半个汉字，换句话说，1个汉字占据2个字节的存储空间。 </p><p><strong>KB</strong></p><ul><li>在一般的计量单位中，通常K表示1000。</li></ul><p>例如：1公里= 1000米，经常被写为1km；1公斤=1000克，写为1kg。同样K在二进制中也有类似的含义。只是这时K表示1024，也就是2的10次方。1KB 表示1K个Byte，也就是1024个字节。MB：计量单位中的M(兆)是10的6次方，见到M自然想起要在该数值的后边续上六个0，即扩大一百万倍。在二进制中，MB也表示到了百万级的数量级，但1MB不正好等于1000000字节，而是1048576字节，即 1MB = 2$ e^{20} $Bytes = 1048576Bytes。 </p><p>在标准10进制公制度量系统中，倍率关系如下所示 </p><p>kilo (k)* = $ 10 ^ 3 $ = 1,000 thousand 千<br>mega (M) = $ 10 ^ 6 $ = 1,000,000 million 百万<br>giga (G) = $ 10 ^ 9 $ = 1,000,000,000 billion 十亿<br>tera (T) = $ 10 ^ {12} $ = 1,000,000,000,000 trillion 万亿 </p><p>==在公制系统中， “k” 或者”kilo” 前缀只使用小写字母== </p><p>在计算机/通讯行业中，计算数据传送速度也使用每秒传送公制数据量来计算 </p><p>1 bit (b) = 0 or 1 = one binary digit 一个二进制位元<br>1 kilobit(kb)=$ 10 ^ 3 $ bits = 1,000 bits 一千位元<br>1 Megabit(Mb)=$ 10 ^ 6 $ bits = 1,000,000 bits 一百万位元<br>1 Gigabit(Gb)=$ 10 ^ 9 $ bits = 1,000,000,000 bits 一万亿位元 </p><p>根据进制规定，传送速度可以有两种表示方法 bps 和 Bps,但是他们是有严格区别。Bps中的 B 使用的是二进制系统中的Byte字节 ,bps中的 b 是十进制系统中的位元。 </p><p>在我们常说的56K拨号，100M局域网都是bps计量，当用于软件下载时，下载工具一般又以Bps计算，所以它们之间有 8 bit=1 Byte 的换算关系，那么56Kbps拨号极限下载速度是 56Kbps/8=7KBps 每秒下载7K字节 。 </p><p>在数据存储，容量计算中，一般又结合公制的进制和二进制的数据计算方法来计算（二进制） </p><p>1 byte (B) = 8 bits (b) 字节=8个二进制位<br>1 Kilobyte(K/KB)=$ 2^{10} $ bytes=1,024 bytes 千字节<br>1 Megabyte(M/MB)=$ 2^{20} $ bytes=1,048,576 bytes 兆字节<br>1 Gigabyte(G/GB)=$ 2^{30} $ bytes=1,073,741,824 bytes 千兆字节<br>1 Terabyte(T/TB)=$ 2^{40} $ bytes=1,099,511,627,776 bytes吉字节 </p><p>一些存储器厂家特别是硬盘厂家就更紧密结合十进制来计算，这就是为什么操作系统显示的容量与厂家标示的容量有些一些差异的原因（十进制） </p><p>1 byte (B) = 8 bits (b)<br>1 Kilobyte (K / KB) = $ 10 ^ 3 $ bytes = 1,000 bytes<br>1 Megabyte (M / MB) = $ 10 ^ 6 $ bytes = 1,000,000 bytes<br>1 Gigabyte (G / GB) = $ 10 ^ 9 $ bytes = 1,000,000,000 bytes<br>1 Terabyte (T / TB) = $ 10 ^ {12} $ bytes = 1,000,000,000,000 bytes </p><p>1． 计算机最小存储计量单位是：BIT（位） </p><p>2． 计算机最基本存储计量单位是：Bytes(字节) </p><p>3． Bit和Bytes的关系：8Bit=1Bytes </p><p>4． 其他常用单位：1KB（1千字节）、1Mb(1兆字节)、1GB（1千兆字节）、1TB（1千G） </p><p>5． 常用单位之间以210 为进制单位即1024为进制。 </p><p>6． 常用单位之间的换算：</p><p>1K=512个汉字（手机）</p><p>1K=1Kb=1024b=8*1024 Bit </p><p>1M=1Mb=1024K=1024Kb=1024*1024B </p><p>1G=1Gb=1024M=1024Mb=1024*1024KB=10243B </p><p>1TB=1024GB=10242MB=10243KB=10244B=8*10244位 </p><p>7． 英文母及符号占用字节 </p><p>(1).在半角状态下1个英文字母或标点符号只占1个字节 </p><p>(2).在全角状态下1个英文字母或标点符号只占2个字节 </p><p>8． 汉字无论在半角还是全角状态下均占2个字节</p><p>参考资料：<a href="http://chongchong.blog.edu.cn/user1/6206/archives/2005/162431.shtml" target="_blank" rel="external">http://chongchong.blog.edu.cn/user1/6206/archives/2005/162431.shtml</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;bit&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电脑记忆体中最小的单位，在二进位电脑系统中，每一bit 可以代表0 或 1 的数位信号。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Byte&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字节单位，一般
      
    
    </summary>
    
      <category term="单位" scheme="https://wonderxiao.github.io/categories/%E5%8D%95%E4%BD%8D/"/>
    
    
      <category term="单位转换" scheme="https://wonderxiao.github.io/tags/%E5%8D%95%E4%BD%8D%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
</feed>
